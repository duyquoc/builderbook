<div id="chapter-content" style="padding: 20px 10%; background-color: white; color: black;"><h2 style="font-weight: 400; line-height: 1.5em; background-color: white; color: black;">Chapter 6: Github integration. Admin dashboard. Testing Admin UX and Github integration.</h2><div style="background-color: white; color: black;"><hr>
<ul>
<li>Github integration <br><ul>
<li>Set up server</li>
<li>syncContent() for Book model</li>
<li>syncContent() for Chapter model</li>
</ul>
</li>
</ul>
<ul>
<li>Markdown to HTML <br></li>
</ul>
<ul>
<li>Admin dashboard <br><ul>
<li>Express routes</li>
<li>API methods</li>
<li>Admin pages and components</li>
<li>Redirects for Admin and Customer users</li>
</ul>
</li>
</ul>
<ul>
<li>Update Header component <br></li>
</ul>
<ul>
<li>Testing <br><ul>
<li>Connecting Github</li>
<li>Adding new book</li>
<li>Editing existing book</li>
<li>Syncing content</li>
</ul>
</li>
</ul>
<hr>
<p>Before you start working on Chapter 6, get the <code>6-begin</code> codebase. The <a target="_blank" href="https://github.com/builderbook/builderbook/tree/master/book/6-begin" rel="noopener noreferrer">6-begin</a> folder is located at the root of the <code>book</code> directory inside the <a target="_blank" href="https://github.com/builderbook/builderbook" rel="noopener noreferrer">builderbook repo</a>.</p>
<ul>
<li>If you haven't cloned the builderbook repo yet, clone it to your local machine with <code>git clone https://github.com/builderbook/builderbook.git</code>.</li>
<li>Inside the <code>6-begin</code> folder, run <code>yarn</code> to install all packages. </li>
</ul>
<p>These are the packages that we install specifically for Chapter 6:</p>
<ul>
<li><code>"@octokit/rest"</code></li>
<li><code>"front-matter"</code></li>
<li><code>"he"</code></li>
<li><code>"highlight.js"</code></li>
<li><code>"marked"</code></li>
<li><code>"qs"</code></li>
<li><code>"request"</code></li>
</ul>
<p>Check out the <a target="_blank" href="https://github.com/builderbook/builderbook/blob/master/book/6-begin/package.json" rel="noopener noreferrer">package.json</a> for Chapter 6.</p>
<ul>
<li>Be sure to use these specific packages and ignore any warnings about upgrading. We regularly upgrade all packages and test them in the book. But before testing, we cannot guarantee that a new package version will work properly.</li>
</ul>
<p>Remember to include your <code>.env</code> at the root of your app. By the end of Chapter 6, you will add <code>Github_Test_ClientID</code> and <code>Github_Test_SecretKey</code> environmental variables to your <code>.env</code> file.</p>
<hr>
<br>

<p>In the previous chapter (Chapter 5), you built a complete internal API twice:</p>
<ul>
<li>you rendered a list of books on the main Admin page (<code>pages/admin/index.js</code>) and</li>
<li>you rendered chapter content on the main Public page (<code>public/read-chapter.js</code>)</li>
</ul>
<p>In this chapter, we will integrate our app with Github, add missing internal APIs for our Admin, and test out the <em>entire</em> Admin experience in our web application. We will test adding a new book, editing it, and syncing its content with Github.</p>
<h2 class="chapter-section" style="color: #FFF; font-weight: 400;">
        <a name="github-integration" href="#github-integration" style="color: #FFF;"> 
          <i class="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer; color: FFF;">
            link
          </i>
        </a>
        <span class="section-anchor" name="github-integration">
          Github integration
        </span>
      </h2><p>This is the section where we finally integrate our app with Github. Let's quickly discuss why we chose Github as our content management system.</p>
<p>First, Github's markdown is familiar to most web developers, and we built our Builder Book app specifically for developers. Our app's Admin user is a web developer who can write, edit, and host chapter content using markdown on his/her favorite code editor or on Github. We prefer Visual Studio code editor (VS editor) for writing content. VS editor, unlike Github, has better scrolling, faster navigation, and lets you save your progress offline.</p>
<p>Second, Github comes with cloud storage for media files, such as images. Without Github, we would have to integrate with AWS S3 or another storage solution. In the final section of this chapter, I'll guide you through a Github integration that takes data from Github servers, saves it to our database, and fetches it inside our web app.</p>
<h4 style="color: #FFF;">
        <a name="set-up-server" href="#set-up-server" style="color: #FFF;">
          <i class="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer; color: FFF;">
              link
            </i>
        </a>
        Set up server
      </h4><p>To integrate our web app with Github, we have to achieve multiple things: </p>
<ol>
<li><p>When a user goes to <code>/auth/github</code>, we redirect the user to Github's authorize endpoint (see <code>AUTHORIZE_URI</code> below), where the user is asked to <code>Authorize application</code>.<br>We will follow the official API docs from Github. Check <a target="_blank" href="https://developer.github.com/v3/guides/basics-of-authentication/#accepting-user-authorization" rel="noopener noreferrer">this example</a> in the basic authentication section. This official example provides the following URLs for <code>authorize</code> and <code>token</code> endpoints:</p>
<pre>https://github.com/login/oauth/authorize?scope=user:email&amp;client_id=&lt;%= client_id %&gt;</pre>

<pre>https://github.com/login/oauth/access_token</pre>

<p>Let's isolate the non-variable part (part without <code>scope</code>, <code>client_id</code>, etc.) of these URLs and point it to variables:</p>
<pre><code><span class="hljs-keyword">const</span> AUTHORIZE_URI = <span class="hljs-symbol">'https</span>:<span class="hljs-comment">//github.com/login/oauth/authorize';</span>
<span class="hljs-keyword">const</span> TOKEN_URI = <span class="hljs-symbol">'https</span>:<span class="hljs-comment">//github.com/login/oauth/access_token';</span></code></pre><p>In step 1, we define an Express route: <code>server.get('/auth/github', (req, res) =&gt; { ... })</code></p>
<p>To get the complete <code>authorize</code> URL (with variables), we will stringify the non-variable part with variables by using the <code>qs.stringify()</code> <a target="_blank" href="https://www.npmjs.com/package/qs#stringifying" rel="noopener noreferrer">method</a> from the <code>qs</code> package. </p>
<p>In step 1, the <code>authorize</code> URL contains <code>client_id</code> and, in step 3, <code>request.post</code> requires <code>client_secret</code> - so we have to define both before we use them:</p>
<pre><code><span class="hljs-keyword">const</span> dev = <span class="hljs-built_in">process</span>.env.NODE_ENV !== <span class="hljs-string">'production'</span>;

<span class="hljs-keyword">const</span> CLIENT_ID = dev ? <span class="hljs-built_in">process</span>.env.Github_Test_ClientID : <span class="hljs-built_in">process</span>.env.Github_Live_ClientID;
<span class="hljs-keyword">const</span> API_KEY = dev ? <span class="hljs-built_in">process</span>.env.Github_Test_SecretKey : <span class="hljs-built_in">process</span>.env.Github_Live_SecretKey;</code></pre><p>We will register our app on Github in the <a target="_blank" href="https://builderbook.org/books/builder-book/github-integration-admin-dashboard-testing-admin-ux-and-github-integration#testing" rel="noopener noreferrer">Testing section</a> of this chapter.</p>
</li>
<li><p>If the user gives permission, Github provides our app with a temporary authorization <code>code</code> value, and the user is redirected to <code>/auth/github/callback</code>.<br>Here, we define the Express route:</p>
<pre>server.get('/auth/github/callback', (req, res) =&gt; { ... })</pre>
</li>
<li><p>Our server sends a POST request with the authorization <code>code</code> to Github's server (at <code>TOKEN_URI</code>) and, in exchange, gets a result that contains either an <code>access_token</code> or error.<br>Since our Express server cannot send a request to Github's server (server to server request instead of server to client response), we use <code>request</code> from the <code>request</code> <a target="_blank" href="https://www.npmjs.com/package/request" rel="noopener noreferrer">package</a> to send a POST request with <code>code</code> (to exchange it for <code>access_token</code>).</p>
<p>Using <code>request</code> is straighforward, and we simply follow <a target="_blank" href="https://www.npmjs.com/package/request#forms" rel="noopener noreferrer">this example</a>:</p>
<pre>request.post({url:'value', form: {key:'value'}}, function(err, httpResponse, body){ /* ... */ })</pre> 

<p>This POST request is sent (<code>request.post()</code>) from inside <code>server.get('/auth/github/callback', (req, res) =&gt; { ... })</code>, our Express route from step 2.</p>
<p>Our Express routes from step 1 and step 2 will be combined in the <code>setupGithub({ server })</code> function. Later in this section, this function will be exported and imported to our main server code at <code>server/app.js</code> to initialize Github integration on the server. </p>
</li>
<li><p>If the result has an <code>access_token</code>, then we update the user's document with:<br><code>isGithubConnected: true, githubAccessToken: result.access_token</code>.<br><code>result</code> comes back from Github in exchange for our POST request with an authorization <code>code</code>. If this <code>result</code> has an <code>access_token</code> - we save it to the user's document. We'll use this <code>access_token</code> in step 5 when we need to access the user's data on Github, such as book content. And as you probaby guessed - we'll use <code>User.updateOne()</code> to update our user.</p>
</li>
<li><p>We need to write a few API functions that return the user's repos, files inside these repos, and repo commits.<br>Here we define a <code>getAPI({ accessToken })</code> function that authenticates the user and sends a request to Github. We will <em>use</em> this function inside: </p>
<ul>
<li><code>getRepos({ accessToken })</code> (to get a list of repos),</li>
<li><code>getContent({ accessToken, repoName, path })</code> (to get content from repo's files) and</li>
<li><code>getCommits({ accessToken, repoName, limit })</code> (to get a list of commits). </li>
</ul>
<p>We will define <code>getAPI({ accessToken })</code> with the help of <code>GithubAPI</code> constructor from the <code>@octokit/rest</code> package by closely following an <a target="_blank" href="https://www.npmjs.com/package/@octokit/rest#usage" rel="noopener noreferrer">official example</a>. More on step 5 at the end of this subsection.</p>
</li>
</ol>
<p>After putting code from steps 1-5 together, we get this code for setting up Github integration on our server:<br><code>server/github.js</code> :</p>
<pre><code><span class="hljs-keyword">const</span> qs = <span class="hljs-keyword">require</span>(<span class="hljs-string">'qs'</span>);
<span class="hljs-keyword">const</span> request = <span class="hljs-keyword">require</span>(<span class="hljs-string">'request'</span>);
<span class="hljs-keyword">const</span> GithubAPI = <span class="hljs-keyword">require</span>(<span class="hljs-string">'@octokit/rest'</span>);

<span class="hljs-keyword">const</span> User = <span class="hljs-keyword">require</span>(<span class="hljs-string">'./models/User'</span>);

<span class="hljs-keyword">const</span> AUTHORIZE_URI = <span class="hljs-string">'https://github.com/login/oauth/authorize'</span>;
<span class="hljs-keyword">const</span> TOKEN_URI = <span class="hljs-string">'https://github.com/login/oauth/access_token'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setupGithub</span><span class="hljs-params">({ server })</span> </span>{
  <span class="hljs-keyword">const</span> dev = process.env.NODE_ENV !== <span class="hljs-string">'production'</span>;

  <span class="hljs-keyword">const</span> CLIENT_ID = dev ? process.env.Github_Test_ClientID : process.env.Github_Live_ClientID;
  <span class="hljs-keyword">const</span> API_KEY = dev ? process.env.Github_Test_SecretKey : process.env.Github_Live_SecretKey;

  server.get(<span class="hljs-string">'/auth/github'</span>, (req, res) =&gt; {
    <span class="hljs-comment">// 1. check if user exists and user is Admin</span>
    <span class="hljs-comment">// If not, redirect to Login page, return undefined.</span>

    <span class="hljs-comment">// 2. Redirect to Github's OAuth endpoint (we will qs.stringify() here)</span>
  });

  server.get(<span class="hljs-string">'/auth/github/callback'</span>, (req, res) =&gt; {
    <span class="hljs-comment">// 3. check if user exists and user is Admin</span>
    <span class="hljs-comment">// If not, redirect to Login page, return undefined.</span>
    <span class="hljs-comment">// (same as 1.) </span>

    <span class="hljs-comment">// 4. return undefined if req.query has error</span>

    <span class="hljs-keyword">const</span> { code } = req.query;

    request.post(
      <span class="hljs-comment">// 5. send request from our server to Github's server</span>

      async (err, r, body) =&gt; {
      <span class="hljs-comment">// 6. return undefined if result has error</span>


        <span class="hljs-comment">// 7. update User document on database</span>
      },
    );
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAPI</span><span class="hljs-params">({ accessToken })</span> </span>{
  <span class="hljs-keyword">const</span> github = <span class="hljs-keyword">new</span> GithubAPI({
    <span class="hljs-comment">// 8. set parameters for new GithubAPI()</span>
  });

  <span class="hljs-keyword">return</span> github;

}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRepos</span><span class="hljs-params">({ accessToken })</span> </span>{
  <span class="hljs-comment">// 9. function that gets list of repos for user</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getContent</span><span class="hljs-params">({ accessToken, repoName, path })</span> </span>{
  <span class="hljs-comment">// 10. function that gets repo's content</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCommits</span><span class="hljs-params">({ accessToken, repoName, limit })</span> </span>{
  <span class="hljs-comment">// 11. function that gets list of repo's commits</span>
}


exports.setupGithub = setupGithub;
exports.getRepos = getRepos;
exports.getContent = getContent;
exports.getCommits = getCommits;</code></pre><p>I've numbered the missing code snippets. We discuss them in detail below.</p>
<ol>
<li><p>Checking if a user exists and if the user is an Admin is straightforward:</p>
<pre>if (!req.user || !req.user.isAdmin)</pre>
<p>If he user doesn't exist, let's redirect to the Login page: <code>res.redirect('/login');</code>. By now, you know how to return <code>undefined</code> with simple <code>return;</code>.<br>Put it all together:</p>
<pre><code><span class="hljs-keyword">if</span> (!req.<span class="hljs-keyword">user</span> || !req.<span class="hljs-keyword">user</span>.isAdmin) {
 res.redirect(<span class="hljs-string">'/login'</span>);
 <span class="hljs-keyword">return</span>;
}</code></pre></li>
<li><p>Following <a target="_blank" href="https://developer.github.com/v3/guides/basics-of-authentication/#accepting-user-authorization" rel="noopener noreferrer">Github's official example</a>, we need to redirect the user (<code>res.redirect()</code>) to the <code>authorize</code> URL.</p>
<p>However, before redirecting to this URL, we want to generate a full <code>authorize</code> URL by adding some parameters to the basic, non-variable part of the <code>authorize</code> URL (we called it <code>AUTHORIZE_URI</code>, see above). </p>
<p>We create a full URL with <code>qs.stringify()</code>, which works like: <code>qs.stringify(object, [parameters]);</code>.<br>In our case:</p>
<pre>`${AUTHORIZE_URI}?${qs.stringify({
 // parameters we want to add to AUTHORIZE_URI
})}`
</pre>

<p>After adding <code>scope</code>, <code>state</code>, <code>client_id</code> parameters, we get:</p>
<pre>res.redirect(`${AUTHORIZE_URI}?${qs.stringify({
 scope: 'repo',
 state: req.session.state,
 client_id: CLIENT_ID,
})}`);
</pre></li>
<li><p>This code snippet is exactly the same as code snippet 1 (see above):</p>
<pre><code><span class="hljs-keyword">if</span> (!req.<span class="hljs-keyword">user</span> || !req.<span class="hljs-keyword">user</span>.isAdmin) {
 res.redirect(<span class="hljs-string">'/login'</span>);
 <span class="hljs-keyword">return</span>;
}</code></pre></li>
<li><p>If the response from Github's server contains an error, we redirect the user and return undefined:</p>
<pre><code><span class="hljs-keyword">if</span> (req.<span class="hljs-keyword">query</span>.<span class="hljs-keyword">error</span>) {
 res.redirect(`/admin?<span class="hljs-keyword">error</span>=<span class="hljs-variable">${req</span>.<span class="hljs-keyword">query</span>.error_description}`);
 <span class="hljs-keyword">return</span>;
}</code></pre></li>
<li><p><em>Else</em>, we send <code>request.post</code> by following <code>request</code>'s example:<br><code>request.post({url:'value', form: {key:'value'}}, function(err, r, body){ /* ... */ })</code> (we renamed <code>httpResponse</code> to <code>response</code>).</p>
<p>This POST request is sent to <code>TOKEN_URI</code> (see above) and contains three parameters: <code>client_id</code>, authorization <code>code</code> (taken from Github's initial response, <code>const { code } = req.query;</code>), and <code>client_secret</code>:</p>
<pre><code>{
 <span class="hljs-attribute">url</span>: TOKEN_URI,
 headers: { Accept: <span class="hljs-string">'application/json'</span> },
 <span class="hljs-selector-tag">form</span>: {
   <span class="hljs-attribute">client_id</span>: CLIENT_ID,
   code,
   client_secret: API_KEY,
 },
},</code></pre><p>The headers <code>{ Accept: 'application/json' }</code> tell Github's server to expect JSON-type data.</p>
</li>
<li><p>If the response has an error, we will redirect the user and return undefined:</p>
<pre><code><span class="hljs-keyword">if</span> (<span class="hljs-keyword">err</span>) {
 res.redirect(`/admin?<span class="hljs-keyword">error</span>=<span class="hljs-variable">${err</span>.message || <span class="hljs-keyword">err</span>.<span class="hljs-keyword">toString</span>()}`);
 <span class="hljs-keyword">return</span>;
}</code></pre></li>
<li><p><em>Else</em>, we will parse the response's <code>body</code> (which is a JSON string) with JavaScript's <code>JSON.parse()</code>. This will produce a JavaScript object. We will point the <code>result</code> variable to this JavaScript object. If the result has an error, we will redirect the user and return undefined:</p>
<pre><code>const <span class="hljs-literal">result</span> = JSON.parse(body);

<span class="hljs-keyword">if</span> (<span class="hljs-literal">result</span>.<span class="hljs-keyword">error</span>) {
 res.redirect(`/admin?<span class="hljs-keyword">error</span>=${<span class="hljs-literal">result</span>.error_description}`);
<span class="hljs-built_in"> return</span>;
}</code></pre></li>
<li><p>Here we follow an <a target="_blank" href="https://octokit.github.io/rest.js/#authentication" rel="noopener noreferrer">example from the docs</a>. We pass <code>auth</code> and <code>request</code> parameters to a <code>new GithubAPI()</code> instance.</p>
<ul>
<li><p><code>auth</code> could be a string, an OAuth access token, in our case <code>accessToken</code> that our app receives from GitHub server after successful authentication</p>
</li>
<li><p><code>request</code> is an object with multiple parameter, we will pass only one parameter <code>timeout</code> and set it to 10,000 ms. If GitHub API does send response in 10 or less seconds, we will see a timeout error</p>
</li>
</ul>
<p>Pass the above parameters above to <code>GithubAPI()</code>:</p>
<pre><code>const github = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GithubAPI({ <span class="hljs-params">auth</span>: <span class="hljs-params">accessToken</span>, <span class="hljs-params">request</span>: { <span class="hljs-params">timeout</span>: 10000 } })</span>;</code></pre></li>
<li><p>This method gets a list of the user's Github repos. Check up <a target="_blank" href="https://octokit.github.io/rest.js/#octokit-routes-repos-list" rel="noopener noreferrer">octokit.repos.list()</a> method.</p>
<p>We've already created a <code>new GitHubApi()</code> instance and called <code>github.authenticate()</code> inside <code>getAPI({ accessToken })</code>. The only thing left is to authenticate request by calling <code>getAPI({ accessToken })</code> and then send request to retrieve list of repos with <code>github.repos.list()</code>:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRepos</span><span class="hljs-params">({ accessToken })</span> </span>{
 <span class="hljs-keyword">const</span> github = getAPI({ accessToken });

 <span class="hljs-keyword">return</span> github.repos.<span class="hljs-keyword">list</span>({ per_page: <span class="hljs-number">100</span> });
}</code></pre><p>We specified to show up to 100 repos per page by using the <code>per_page</code> parameter. <code>github.repos.list()</code> accepts multiple parameters. For a list of all parameters, search <code>repos.list()</code> in the <a target="_blank" href="https://octokit.github.io/rest.js/#octokit-routes-repos-list" rel="noopener noreferrer">documentation</a>.</p>
</li>
<li><p>This method gets a repo's content by calling the <code>github.repos.getContents({ owner, repo, path })</code> API method. As you can see by searching <code>getContents</code> in <a target="_blank" href="https://octokit.github.io/rest.js/#octokit-routes-repos-get-contents" rel="noopener noreferrer">the docs</a>, this method requires three parameters: <code>owner</code>, <code>repo</code> and <code>path</code>. The fourth parameter <code>ref</code> is optional.</p>
<p>When we write the static method <code>syncContent()</code> for our Book and Chapter models, we will take <code>owner</code> and <code>repo</code> values from <code>repoName: book.githubRepo</code>. For example, if the <code>repoName</code> is <code>builderbook/book-1</code>, then <code>owner</code> is <code>builderbook</code> and <code>repo</code> is <code>book-1</code>. We reflect that by using ES6's destructuring and JavaScript's <code>split()</code> method:</p>
<pre>const [owner, repo] = repoName.split('/');</pre>

<p>Again, we point <code>github</code> to <code>getAPI({ accessToken })</code> and call <code>github.repos.getContents({ owner, repo, path })</code>:</p>
<pre><code><span class="hljs-keyword">function</span> get<span class="hljs-constructor">Content({ <span class="hljs-params">accessToken</span>, <span class="hljs-params">repoName</span>, <span class="hljs-params">path</span> })</span> {
const github = get<span class="hljs-constructor">API({ <span class="hljs-params">accessToken</span> })</span>;
const <span class="hljs-literal">[<span class="hljs-identifier">owner</span>, <span class="hljs-identifier">repo</span>]</span> = repoName.split(<span class="hljs-character">'/'</span>);

return github.repos.get<span class="hljs-constructor">Contents({ <span class="hljs-params">owner</span>, <span class="hljs-params">repo</span>, <span class="hljs-params">path</span> })</span>;
}</code></pre><p>Note, if the repo's root directory contains files with chapter content, then the <code>path</code> value is <code>'/'</code>.</p>
</li>
<li><p>The <code>getCommits()</code> method is optional; however it's good practice to have. This method gets a list of repo commits. We take the latest commit and save it to our database. When we sync content between our database and the Github repo - we check if the latest commit id is the same. If it is, then the content in our database is up-to-date.<br>Check up the <a target="_blank" href="https://octokit.github.io/rest.js/#octokit-routes-repos-list-commits" rel="noopener noreferrer">list of parameters</a> for the <code>repos.listCommits()</code> method. Two required parameters are <code>owner</code> and <code>repo</code>. Again, we take the values of these parameters by splitting <code>repoName</code>:</p>
<pre>const [owner, repo] = repoName.split('/');</pre>

<p>And again, we point <code>github</code> to <code>getAPI({ accessToken })</code> and call <code>github.repos.listCommits({ owner, repo, per_page: limit })</code>:</p>
<pre><code><span class="hljs-keyword">function</span> get<span class="hljs-constructor">Commits({ <span class="hljs-params">accessToken</span>, <span class="hljs-params">repoName</span>, <span class="hljs-params">limit</span> })</span> {
const github = get<span class="hljs-constructor">API({ <span class="hljs-params">accessToken</span> })</span>;
const <span class="hljs-literal">[<span class="hljs-identifier">owner</span>, <span class="hljs-identifier">repo</span>]</span> = repoName.split(<span class="hljs-character">'/'</span>);

return github.repos.<span class="hljs-built_in">list</span><span class="hljs-constructor">Commits({ <span class="hljs-params">owner</span>, <span class="hljs-params">repo</span>, <span class="hljs-params">per_page</span>: <span class="hljs-params">limit</span> })</span>;
}</code></pre><p>We will specify <code>limit: 1</code> (in the static method for our Book model) to get only the one latest commit. Our static method will save the latest commit's hash to our database as <code>githubLastCommitSha</code> and compare it to Github's value every time the Admin user syncs content between the database and his/her Github repo.</p>
</li>
</ol>
<p>Plug the twelve snippets of code above into our carcass for <code>server/github.js</code> :<br><code>server/github.js</code> :</p>
<pre><code><span class="hljs-keyword">const</span> qs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'qs'</span>);
<span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">'request'</span>);
<span class="hljs-keyword">const</span> GithubAPI = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@octokit/rest'</span>);

<span class="hljs-keyword">const</span> User = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./models/User'</span>);

<span class="hljs-keyword">const</span> TOKEN_URI = <span class="hljs-string">'https://github.com/login/oauth/access_token'</span>;
<span class="hljs-keyword">const</span> AUTHORIZE_URI = <span class="hljs-string">'https://github.com/login/oauth/authorize'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setupGithub</span>(<span class="hljs-params">{ server }</span>) </span>{
  <span class="hljs-keyword">const</span> dev = process.env.NODE_ENV !== <span class="hljs-string">'production'</span>;

  <span class="hljs-keyword">const</span> CLIENT_ID = dev ? process.env.Github_Test_ClientID : process.env.Github_Live_ClientID;
  <span class="hljs-keyword">const</span> API_KEY = dev ? process.env.Github_Test_SecretKey : process.env.Github_Live_SecretKey;

  server.get(<span class="hljs-string">'/auth/github'</span>, (req, res) =&gt; {
    <span class="hljs-keyword">if</span> (!req.user || !req.user.isAdmin) {
      res.redirect(<span class="hljs-string">'/login'</span>);
      <span class="hljs-keyword">return</span>;
    }

    res.redirect(<span class="hljs-string">`<span class="hljs-subst">${AUTHORIZE_URI}</span>?<span class="hljs-subst">${qs.stringify({
      scope: <span class="hljs-string">'repo'</span>,
      state: req.session.state,
      client_id: CLIENT_ID,
    }</span>)}`</span>);
  });

  server.get(<span class="hljs-string">'/auth/github/callback'</span>, (req, res) =&gt; {
    <span class="hljs-keyword">if</span> (!req.user || !req.user.isAdmin) {
      res.redirect(<span class="hljs-string">'/login'</span>);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (req.query.error) {
      res.redirect(<span class="hljs-string">`/admin?error=<span class="hljs-subst">${req.query.error_description}</span>`</span>);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">const</span> { code } = req.query;

    request.post(
      {
        <span class="hljs-attr">url</span>: TOKEN_URI,
        <span class="hljs-attr">headers</span>: { <span class="hljs-attr">Accept</span>: <span class="hljs-string">'application/json'</span> },
        <span class="hljs-attr">form</span>: {
          <span class="hljs-attr">client_id</span>: CLIENT_ID,
          code,
          <span class="hljs-attr">client_secret</span>: API_KEY,
        },
      },
      <span class="hljs-keyword">async</span> (err, response, body) =&gt; {
        <span class="hljs-keyword">if</span> (err) {
          res.redirect(<span class="hljs-string">`/admin?error=<span class="hljs-subst">${err.message || err.toString()}</span>`</span>);
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">JSON</span>.parse(body);

        <span class="hljs-keyword">if</span> (result.error) {
          res.redirect(<span class="hljs-string">`/admin?error=<span class="hljs-subst">${result.error_description}</span>`</span>);
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">await</span> User.updateOne(
            { <span class="hljs-attr">_id</span>: req.user.id },
            { <span class="hljs-attr">$set</span>: { <span class="hljs-attr">isGithubConnected</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">githubAccessToken</span>: result.access_token } },
          );
          res.redirect(<span class="hljs-string">'/admin'</span>);
        } <span class="hljs-keyword">catch</span> (err2) {
          res.redirect(<span class="hljs-string">`/admin?error=<span class="hljs-subst">${err2.message || err2.toString()}</span>`</span>);
        }
      },
    );
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAPI</span>(<span class="hljs-params">{ accessToken }</span>) </span>{
  <span class="hljs-keyword">const</span> github = <span class="hljs-keyword">new</span> GithubAPI({ <span class="hljs-attr">auth</span>: accessToken, <span class="hljs-attr">request</span>: { <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span> } });

  <span class="hljs-keyword">return</span> github;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRepos</span>(<span class="hljs-params">{ accessToken }</span>) </span>{
  <span class="hljs-keyword">const</span> github = getAPI({ accessToken });

  <span class="hljs-keyword">return</span> github.repos.list({ <span class="hljs-attr">per_page</span>: <span class="hljs-number">100</span> });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getContent</span>(<span class="hljs-params">{ accessToken, repoName, path }</span>) </span>{
  <span class="hljs-keyword">const</span> github = getAPI({ accessToken });
  <span class="hljs-keyword">const</span> [owner, repo] = repoName.split(<span class="hljs-string">'/'</span>);

  <span class="hljs-keyword">return</span> github.repos.getContents({ owner, repo, path });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCommits</span>(<span class="hljs-params">{ accessToken, repoName, limit }</span>) </span>{
  <span class="hljs-keyword">const</span> github = getAPI({ accessToken });
  <span class="hljs-keyword">const</span> [owner, repo] = repoName.split(<span class="hljs-string">'/'</span>);

  <span class="hljs-keyword">return</span> github.repos.listCommits({ owner, repo, <span class="hljs-attr">per_page</span>: limit });
}

exports.setupGithub = setupGithub;
exports.getRepos = getRepos;
exports.getContent = getContent;
exports.getCommits = getCommits;</code></pre><p>The last three exported functions get user data such as repo, repo files, and repo commits from Github. The next step is to use these functions inside the static method <code>syncContent()</code> of our Book and Chapter models. As you may guess from the name, <code>Book.syncContent()</code> and <code>Chapter.syncContent()</code> static methods - with the help of <code>getRepos()</code>, <code>getContent()</code>, and <code>getCommits()</code> functions - will <em>get and sync data</em> for our book and chapters from Github. </p>
<h4 style="color: #FFF;">
        <a name="synccontent-for-book-model" href="#synccontent-for-book-model" style="color: #FFF;">
          <i class="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer; color: FFF;">
              link
            </i>
        </a>
        syncContent() for Book model
      </h4><p>In the previous subsection, we wrote code for Github integration. We defined and exported a <code>setupGithub({ server })</code> function - this function has all necessary Express routes and will later be imported to our main server code at <code>server/app.js</code>. We defined and exported three API methods:</p>
<ul>
<li><code>getRepos({ accessToken })</code>,</li>
<li><code>getContent({ accessToken, repoName, path })</code>,</li>
<li><code>getCommits({ accessToken, repoName, limit })</code>.</li>
</ul>
<p>But we are not done with Github integration yet. We have a few more tasks, which you should be familiar with:</p>
<ul>
<li>update our Book and Chapter models with a static method that employs the three API methods above,</li>
<li>write an Express route with API endpoints (<code>server/api/admin.js</code>),</li>
<li>write API methods (<code>lib/api/admin.js</code>),</li>
<li>add missing pages to <code>pages/admin/*</code>.</li>
</ul>
<p>Let's start with the first point. In this subsection, our goal is to <em>use</em> our three API methods to define a static method <code>syncContent()</code> for our Book model. After an Admin user creates a book and decides to get content from Github, our app will execute <code>syncContent()</code> to get all necessary data and save that data to our database.</p>
<p>Take a look at our Book model at <code>server/models/Book.js</code>. We already defined a static method <code>add()</code> (<code>static async add({ name, price, githubRepo })</code>). Our Admin user sets a name + price and calls <code>add()</code> from <code>pages/admin/add-book.js</code> to create a new book. Our new static method <code>syncContent()</code> updates content for an <em>existing</em> book. In other words, the Admin users calls <code>syncContent()</code> <em>after</em> creating a book on his/her database.</p>
<p><code>syncContent()</code> will be <code>async</code>. The method will find a book by its <code>id</code> and pass a user's <code>githubAccessToken</code> to Github's API methods defined earlier:<br><code>server/models/Book.js</code> :</p>
<pre><code>static async syncContent({ id, githubAccessToken }) {
  // <span class="hljs-number">1</span>. await find book by id

  // <span class="hljs-number">2</span>. <span class="hljs-built_in">throw</span> <span class="hljs-built_in">error</span> <span class="hljs-keyword">if</span> there <span class="hljs-built_in">is</span> no book

  // <span class="hljs-number">3</span>. <span class="hljs-built_in">get</span> <span class="hljs-built_in">last</span> commit from Github using `getCommits()` API <span class="hljs-built_in">method</span>

  // <span class="hljs-number">4</span>. <span class="hljs-keyword">if</span> there <span class="hljs-built_in">is</span> no <span class="hljs-built_in">last</span> commit on Github - no need to sync <span class="hljs-built_in">content</span>, <span class="hljs-built_in">throw</span> <span class="hljs-built_in">error</span>

  // <span class="hljs-number">5</span>. <span class="hljs-keyword">if</span> <span class="hljs-built_in">last</span> commit's hash on Github's repo <span class="hljs-built_in">is</span> the same as hash saved <span class="hljs-keyword">in</span> database -
  // no need to extract <span class="hljs-built_in">content</span> from repo, <span class="hljs-built_in">throw</span> <span class="hljs-built_in">error</span>

  // <span class="hljs-number">6</span>. <span class="hljs-built_in">define</span> repo's main folder with `await` <span class="hljs-keyword">and</span> `getContent()`

  await Promise.all(mainFolder.data.<span class="hljs-built_in">map</span>(async (f) =&gt; {
    // <span class="hljs-number">7</span>. check <span class="hljs-keyword">if</span> main folder has files, check <span class="hljs-built_in">title</span> of files
    // <span class="hljs-number">8</span>. <span class="hljs-built_in">define</span> `chapter` with `await` <span class="hljs-keyword">and</span> `getContent()`
    // <span class="hljs-number">9</span>. Extract <span class="hljs-built_in">content</span> from each qualifying file <span class="hljs-keyword">in</span> repo
    // <span class="hljs-number">10</span>. For each file, run `Chapter.syncContent({ book, data })`
  }

  // <span class="hljs-number">11</span>. Return book with updated `githubLastCommitSha`
}</code></pre><p>The section above is a high-level structure (carcass) of the <code>syncContent()</code> static method. As always, before we write code, let's discuss the purpose of each code snippet.</p>
<ol>
<li><p><code>syncContent()</code> is an async function. Inside it, we will find a book with Mongoose's <code>findById()</code> <a target="_blank" href="http://mongoosejs.com/docs/api.html#model_Model.findById" rel="noopener noreferrer">method</a>: <code>Model.findById(id, [projection])</code>.<br>The optional array <code>[projection]</code> is an array of parameter values that we want to return from a Model.<br>In this case, we want to return two book parameters: <code>githubRepo</code> and <code>githubLastCommitSha</code>:</p>
<pre>const book = await this.findById(id, 'githubRepo githubLastCommitSha');</pre></li>
<li><p>We did this one many times before. If there is no book (<code>if (!book)</code>), throw an error (<code>throw new Error('some informative text')</code>):</p>
<pre><code><span class="hljs-keyword">if</span> (!book) {
 <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Error</span>(<span class="hljs-string">'Book not found'</span>);
}</code></pre></li>
<li><p>Here we <code>await</code> for the <code>getCommits()</code> API method to get our repo's latest commit from Github. Remember this method takes three parameters <code>getCommits({ accessToken, repoName, limit })</code>. <code>accessToken</code> to authenticate the user, <code>repoName</code> to get and pass <code>owner</code> and <code>repo</code>, <code>limit</code> to limit the number of commits returned.</p>
<pre><code><span class="hljs-attr">const</span> <span class="hljs-string">lastCommit = await getCommits({</span>
 <span class="hljs-attr">accessToken</span>: <span class="hljs-string">githubAccessToken,</span>
 <span class="hljs-attr">repoName</span>: <span class="hljs-string">book.githubRepo,</span>
 <span class="hljs-attr">limit</span>: <span class="hljs-string">1,</span>
<span class="hljs-attr">});</span></code></pre><p>As discussed in the previous subsection, <code>getCommits()</code> returns a list of commits in reverse chronological order - that's why <code>limit: 1</code> ensures that we get the most recent commit.</p>
</li>
<li><p>Here we are being overcautious and throw an error in the following three cases:</p>
<ul>
<li>if there is no list of commits for the repo (<code>if (!lastCommit)</code>) <em>or</em></li>
<li>if there are no elements inside the list of commits (<code>!lastCommit.data</code>) <em>or</em></li>
<li>if there is no first element in the list of commits (first element has index 0, <code>!lastCommit.data[0]</code>)</li>
<li>then we won't extract any data from the repo; instead we will throw an error (<code>throw new Error('some informative text')</code>):<pre><code><span class="hljs-title">if</span> (!lastCommit || !lastCommit.<span class="hljs-class"><span class="hljs-keyword">data</span> || !lastCommit.<span class="hljs-keyword">data</span>[0]) {
<span class="hljs-title">throw</span> <span class="hljs-title">new</span> <span class="hljs-type">Error</span>('<span class="hljs-type">No</span> <span class="hljs-title">change</span> <span class="hljs-title">in</span> <span class="hljs-title">content</span>!');
}</span></code></pre></li>
</ul>
</li>
<li><p>First, we define <code>lastCommitSha</code> as <code>lastCommit.data[0].sha</code>. From code snippet 4, you know that <code>lastCommit.data[0]</code> is simply the first element in the list of commits - i.e. the last commit, since the list is ordered in reverse chronology.</p>
<p>If the hash of the last commit in the Github repo <code>lastCommitSha</code> is the same as hash saved to the database <code>book.githubLastCommitSha</code>, then all content in the database is up-to-date. No need to extract data, so we throw an error:</p>
<pre><code> <span class="hljs-attribute">const</span> <span class="hljs-literal">last</span>CommitSha = <span class="hljs-literal">last</span>Commit.data[<span class="hljs-number">0</span>].sha;
 <span class="hljs-attribute">if</span> (<span class="hljs-literal">last</span>CommitSha === book.githubLastCommitSha) {
   <span class="hljs-attribute">throw</span> new Error(<span class="hljs-string">'No change in content!'</span>);
 }</code></pre></li>
<li><p>The main folder in a Github repo has <code>path: ''</code>. Let's defile the <code>mainFolder</code> using the <code>getContent()</code> API method. This method takes three parameters, <code>getContent({ accessToken, repoName, path })</code>:</p>
<pre><code> <span class="hljs-attr">const</span> <span class="hljs-string">mainFolder = await getContent({</span>
   <span class="hljs-attr">accessToken</span>: <span class="hljs-string">githubAccessToken,</span>
   <span class="hljs-attr">repoName</span>: <span class="hljs-string">book.githubRepo,</span>
   <span class="hljs-attr">path</span>: <span class="hljs-string">'',</span>
 <span class="hljs-attr">});</span></code></pre></li>
<li><p>In our carcass, you may have noticed this construct:</p>
<pre><code><span class="hljs-keyword">await</span> Promise.all(mainFolder.data.map(<span class="hljs-keyword">async</span> (f) =&gt; {
 <span class="hljs-comment">// some code</span>
}</code></pre><p>As you already know, <code>await</code> pauses code until <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener noreferrer">Promise.all(iterable)</a> returns a single resolved promise after <em>all</em> promises inside <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noopener noreferrer">iterable</a> have been resolved.</p>
<p>In our case, iterable is <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener noreferrer">.map()</a>. This JavaScript method iterates through all <code>.md</code> files with proper names inside mainFolder:</p>
<pre><code><span class="hljs-keyword">if</span> (f.<span class="hljs-built_in">type</span> !== <span class="hljs-string">'file'</span>) {
 <span class="hljs-keyword">return</span>;
}

<span class="hljs-keyword">if</span> (f.<span class="hljs-built_in">path</span> !== <span class="hljs-string">'introduction.md'</span> &amp;&amp; !/chapter-([<span class="hljs-number">0</span><span class="hljs-number">-9</span>]+)\.md/.test(f.<span class="hljs-built_in">path</span>)) {
 <span class="hljs-keyword">return</span>;
}</code></pre><p>First, our construct checks if the content inside <code>mainFolder.data</code> is a file. If not, the code returns undefined. Second, our construct checks if a file's path is <code>introduction.md</code> or <code>chapter-d.md</code>. If not, the code returns undefined. In this second construct, JavaScript's <code>.test(f.path)</code> tests if <code>f.path</code> equals <code>/chapter-([0-9]+)\.md/</code> and returns false if not. Read more about <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test" rel="noopener noreferrer">.test()</a>.</p>
</li>
<li><p>Here we define <code>chapter</code> using the <code>getContent()</code> API method. You remember that this method takes three parameters <code>getContent({ accessToken, repoName, path })</code>. The method passes <code>accessToken</code> to <code>github.authenticate()</code>, splits <code>repoName</code> to extract <code>repo</code> and <code>owner</code>, and uses <code>path</code> to specify a repo file to get content from.</p>
<pre><code><span class="hljs-attr">const</span> <span class="hljs-string">chapter = await getContent({</span>
 <span class="hljs-attr">accessToken</span>: <span class="hljs-string">githubAccessToken,</span>
 <span class="hljs-attr">repoName</span>: <span class="hljs-string">book.githubRepo,</span>
 <span class="hljs-attr">path</span>: <span class="hljs-string">f.path,</span>
<span class="hljs-attr">});</span></code></pre></li>
<li><p>After we define <code>chapter</code>, we need to extract content from the <code>.md</code> file. We use the <a target="_blank" href="https://www.npmjs.com/package/front-matter" rel="noopener noreferrer">front-matter</a> package to extract data. Using <code>front-matter</code> is straightforward, check up an <a target="_blank" href="https://github.com/jxson/front-matter#example" rel="noopener noreferrer">official example</a>: <code>frontmatter(string)</code>. Below, we use this method to extract <code>data</code> from the <code>utf8</code> string:</p>
<pre>const data = frontmatter(Buffer.from(chapter.data.content, 'base64').toString('utf8'));</pre>

<p>You might get confused by the argument inside <code>frontmatter()</code>:</p>
<pre>Buffer.from(chapter.data.content, 'base64').toString('utf8')</pre>

<p><a target="_blank" href="https://nodejs.org/api/buffer.html#buffer_buffer" rel="noopener noreferrer">Buffer</a> is a class in Node designed for handling raw <em>binary</em> data. Github API methods return <em>base64</em> encoded content (see <a target="_blank" href="https://developer.github.com/v3/repos/contents/" rel="noopener noreferrer">docs</a>). Thus, we use Buffer to handle base64-encoded <code>chapter.data.content</code> content from Github.</p>
<p>We handle binary data from Github by using <code>Buffer.from(string[, encoding])</code>. This method creates a new Buffer that contains a copy of the provided <code>string</code> (see <a target="_blank" href="https://nodejs.org/api/buffer.html#buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe" rel="noopener noreferrer">Node docs</a>):</p>
<pre>Buffer.from(chapter.data.content, 'base64')</pre>

<p>Then we use the <code>.toString([encoding])</code> method to convert binary data to a <code>utf-8</code> string (see <a target="_blank" href="https://nodejs.org/api/buffer.html#buffer_buf_tostring_encoding_start_end" rel="noopener noreferrer">Node docs</a>):</p>
<pre>.toString('utf8')</pre>

<p>Though not important for building this app, you are welcome to read more about <a target="_blank" href="https://en.wikipedia.org/wiki/Base64#Examples" rel="noopener noreferrer">base64</a> and <a target="_blank" href="https://en.wikipedia.org/wiki/UTF-8#Examples" rel="noopener noreferrer">utf-8</a>.</p>
</li>
<li><p>Here we pass <code>data</code> from code snippet 9 to the <code>syncContent()</code> static method inside our <em>Chapter model</em> : <code>Chapter.syncContent({ book, data })</code>. We pass <code>book</code> data as well. As you may guess, this particular <code>syncContent()</code> <em>creates</em> a chapter document in the Chapter collection. This chapter document contains the proper <code>bookId</code> (from <code>book</code> data) and proper <code>content</code> (from <code>data</code>). Example of code that creates a chapter document:</p>
<pre><code><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.create({
<span class="hljs-string">bookId:</span> book._id,
<span class="hljs-string">githubFilePath:</span> path,
<span class="hljs-string">content:</span> body,
<span class="hljs-comment">// more parameters</span>
});</code></pre><p>You see that the <code>githubFilePath</code> parameter is simply <code>path</code>, so we have to pass <code>path</code> to <code>data</code> with: </p><pre>data.path = f.path</pre><p></p>
<p>As always, let's use the <code>try/catch</code> construct:</p>
<pre><code>data<span class="hljs-built_in">.path</span> = f<span class="hljs-built_in">.path</span>;

<span class="hljs-keyword">try</span> {
await Chapter.syncContent({ book, data });
logger.info(<span class="hljs-string">'Content is synced'</span>, {<span class="hljs-built_in"> path</span>: f<span class="hljs-built_in">.path</span> });
} <span class="hljs-keyword">catch</span> <span class="hljs-built_in">(error</span>) {
logger<span class="hljs-built_in">.error</span>(<span class="hljs-string">'Content sync has error'</span>, {<span class="hljs-built_in"> path</span>: f<span class="hljs-built_in">.path</span>,<span class="hljs-built_in"> error</span> });
}</code></pre></li>
<li><p>We want <code>syncContent()</code> in our Book model to return a book with an <em>updated</em> <code>githubLastCommitSha</code> parameter (this is the hash of the repo's latest commit from Github):</p>
<pre>return book.update({ githubLastCommitSha: lastCommitSha });</pre>

</li>
</ol>
<p>Good job, now the easy part - plug in these 11 code snippets into the <code>syncContent()</code> carcass for for our Book model:</p>
<pre><code><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> syncContent({ id, githubAccessToken }) {
  <span class="hljs-keyword">const</span> book = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.findById(id, <span class="hljs-string">'githubRepo githubLastCommitSha'</span>);

  <span class="hljs-keyword">if</span> (!book) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Not found'</span>);
  }

  <span class="hljs-keyword">const</span> lastCommit = <span class="hljs-keyword">await</span> getCommits({
    <span class="hljs-attr">accessToken</span>: githubAccessToken,
    <span class="hljs-attr">repoName</span>: book.githubRepo,
    <span class="hljs-attr">limit</span>: <span class="hljs-number">1</span>,
  });

  <span class="hljs-keyword">if</span> (!lastCommit || !lastCommit.data || !lastCommit.data[<span class="hljs-number">0</span>]) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'No change!'</span>);
  }

  <span class="hljs-keyword">const</span> lastCommitSha = lastCommit.data[<span class="hljs-number">0</span>].sha;
  <span class="hljs-keyword">if</span> (lastCommitSha === book.githubLastCommitSha) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'No change!'</span>);
  }

  <span class="hljs-keyword">const</span> mainFolder = <span class="hljs-keyword">await</span> getContent({
    <span class="hljs-attr">accessToken</span>: githubAccessToken,
    <span class="hljs-attr">repoName</span>: book.githubRepo,
    <span class="hljs-attr">path</span>: <span class="hljs-string">''</span>,
  });

  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(mainFolder.data.map(<span class="hljs-keyword">async</span> (f) =&gt; {
    <span class="hljs-keyword">if</span> (f.type !== <span class="hljs-string">'file'</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (f.path !== <span class="hljs-string">'introduction.md'</span> &amp;&amp; !<span class="hljs-regexp">/chapter-(\[0-9]+)\.md/</span>.test(f.path)) {
    <span class="hljs-comment">// not chapter content, skip</span>
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">const</span> chapter = <span class="hljs-keyword">await</span> getContent({
      <span class="hljs-attr">accessToken</span>: githubAccessToken,
      <span class="hljs-attr">repoName</span>: book.githubRepo,
      <span class="hljs-attr">path</span>: f.path,
    });

    <span class="hljs-keyword">const</span> data = frontmatter(Buffer.from(chapter.data.content, <span class="hljs-string">'base64'</span>).toString(<span class="hljs-string">'utf8'</span>));

    data.path = f.path;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> Chapter.syncContent({ book, data });
      logger.info(<span class="hljs-string">'Content is synced'</span>, { <span class="hljs-attr">path</span>: f.path });
    } <span class="hljs-keyword">catch</span> (error) {
      logger.error(<span class="hljs-string">'Content sync has error'</span>, { <span class="hljs-attr">path</span>: f.path, error });
    }
  }));

  <span class="hljs-keyword">return</span> book.update({ <span class="hljs-attr">githubLastCommitSha</span>: lastCommitSha });
}</code></pre><p><em>Important</em> - remember to add this static method above to our Book model at <code>server/models/Book.js</code>. Add it after the <code>static async edit()</code> static method.</p>
<p>Make sure that you have all necessary imports for the <code>server/models/Book.js</code> file:</p>
<pre><code><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
<span class="hljs-keyword">const</span> frontmatter = <span class="hljs-built_in">require</span>(<span class="hljs-string">'front-matter'</span>);
<span class="hljs-keyword">const</span> generateSlug = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../utils/slugify'</span>);
<span class="hljs-keyword">const</span> { getCommits, getContent } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../github'</span>);
<span class="hljs-keyword">const</span> logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../logs'</span>);</code></pre><p>Make sure that you imported <code>Chapter</code> model at the very end of <code>server/models/Book.js</code> file. Since <code>Book</code> and <code>Chapter</code> models are circularly dependent. See Chapter 5 to learn more about circular dependencies.</p>
<h4 style="color: #FFF;">
        <a name="synccontent-for-chapter-model" href="#synccontent-for-chapter-model" style="color: #FFF;">
          <i class="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer; color: FFF;">
              link
            </i>
        </a>
        syncContent() for Chapter model
      </h4><p>We passed <code>book</code> and <code>data</code> to our Chapter model with <code>Chapter.syncContent({ book, data });</code>. This method will create a chapter document in the Chapter collection <em>or</em> if the document already exists, that document will be updated.</p>
<p>Before we continue, we need to understand the structure of data returned by the <a target="_blank" href="https://github.com/jxson/front-matter" rel="noopener noreferrer">front-matter</a> package. For a Github <code>.md</code> file that looks like:<br><img src="https://user-images.githubusercontent.com/10218864/34592422-ba17d474-f178-11e7-87af-916e8d9e9dfd.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<p><code>frontmatter()</code> method returns:<br><img src="https://user-images.githubusercontent.com/10218864/34592474-29a2a3be-f179-11e7-8562-99239ba9425b.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<p>Now that we know the structure, we use ES6 object destructuring for <code>data.attributes.title</code>, <code>data.attributes.excerpt</code>, <code>data.attributes.isFree</code>, <code>data.attributes.seoTitle</code>, <code>data.attributes.seoDescription</code>, <code>data.body</code>, and <code>data.path</code>:</p>
<pre><code><span class="hljs-keyword">const</span> {
  title,
  excerpt = <span class="hljs-string">''</span>,
  isFree = <span class="hljs-literal">false</span>,
  seoTitle = <span class="hljs-string">''</span>,
  seoDescription = <span class="hljs-string">''</span>,
} = <span class="hljs-keyword">data</span>.attributes;

<span class="hljs-keyword">const</span> { body, path } = <span class="hljs-keyword">data</span>;</code></pre><p>Remember that we defined <code>data.path = f.path</code> in <code>syncContent()</code> of our Book model.</p>
<p>Next, let's assume the chapter document exists. In this case, we attempt to find it with Mongoose's <code>findOne()</code>. We search using two parameters: <code>bookId</code> and <code>githubFilePath</code>:</p>
<pre><code><span class="hljs-keyword">const</span> chapter = <span class="hljs-function">await <span class="hljs-keyword">this</span>.<span class="hljs-title">findOne</span><span class="hljs-params">({
  bookId: book.id,
  githubFilePath: path,
})</span></span>;</code></pre><p>Remember that we passed the <code>book</code> object with <code>syncContent({ book, data })</code> and <code>bookId: book.id</code>. We defined <code>path</code> with <code>const { body, path } = data;</code> and passed it with <code>data.path = f.path</code>.</p>
<p>We also need a parameter to specify the order in which a chapter is displayed inside the Table of Contents. For example, we want a chapter with content from <code>introduction.md</code> to have <code>order = 1</code> and a chapter with content from <code>chapter-1.md</code> to have <code>order = 2</code>: </p>
<pre><code><span class="hljs-keyword">let</span> <span class="hljs-keyword">order</span>;

<span class="hljs-keyword">if</span> <span class="hljs-built_in">(path</span> === <span class="hljs-string">'introduction.md'</span>) {
  <span class="hljs-keyword">order</span> = <span class="hljs-number">1</span>;
} <span class="hljs-keyword">else</span> {
  <span class="hljs-keyword">order</span> = parseInt<span class="hljs-built_in">(path</span>.match(/[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+/), <span class="hljs-number">10</span>) + <span class="hljs-number">1</span>;
}    </code></pre><p>We would like to find a number inside each chapter's path. For example, for path <code>chapter-3.md</code>, we want to return <code>order = 4</code> (introduction chapter with path <code>introduction.md</code> has <code>order = 1</code>). To do so, we use JavaScript's methods <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match" rel="noopener noreferrer">str.match(regexp)</a> and <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt" rel="noopener noreferrer">parseInt(string, radix)</a>.</p>
<p>The first JavaScript method finds <code>regexp</code> inside <code>str</code>. In our case, <code>regexp</code> or <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" rel="noopener noreferrer">regular expression</a> is a digit, and <code>str</code> is a <code>path</code>. Regular expression for <em>digit</em> is <code>[0-9]</code> or <code>/d</code>. In order to find multiple digits inside a string, we add <code>+</code>. Without <code>+</code>, we will not get <code>order = 14</code> for the path <code>chapter-13.md</code>, since only <code>1</code> will be found instead of <code>13</code>.</p>
<p>The second JavaScript method parses the resulting string and returns the integer that it finds. Radix is <code>10</code>, since we want to return a decimal system integer. If we don't use <code>parseInt()</code>, then instead of adding <code>1</code> to the number, we will join <code>1</code> to the string and return a joint string. For example, without <code>parseInt()</code>, the <code>order</code> for <code>path</code> <code>chapter-3.md</code> will be <code>31</code> instead of <code>4</code>. Moreover, the <code>order</code> will be a string, not a number.</p>
<p>Whenever possible, when using JavaScript methods, we like to test out code on our browser console. Go to Chrome's <code>Developer tools</code>, click <code>Console</code>, and paste the following code:</p>
<pre><code><span class="hljs-type">path</span> = <span class="hljs-string">'chapter-3.md'</span>;
<span class="hljs-keyword">order</span> = parseInt(<span class="hljs-type">path</span>.match(/[<span class="hljs-number">0</span><span class="hljs-number">-9</span>]+/), <span class="hljs-number">10</span>) + <span class="hljs-number">1</span>;
console.log(typeof(<span class="hljs-keyword">order</span>), <span class="hljs-keyword">order</span>)</code></pre><p>Run the code by clicking <code>Enter</code>. As expected, the output is <code>number 4</code>:<br><img src="https://user-images.githubusercontent.com/10218864/35013813-6481cf98-fac3-11e7-8970-9811a3b1fa68.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<p>Try removing <code>+</code> from <code>[0-9]+</code> and replacing <code>chapter-3.md</code> with <code>chapter-13.md</code>. Run the code. The <code>order</code> will be <code>2</code> instead of <code>14</code>:<br><img src="https://user-images.githubusercontent.com/10218864/35013875-a7bc61a6-fac3-11e7-86d1-54c596ba1172.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<p>Add <code>+</code> back and replace <code>chapter-13.md</code> with <code>chapter-3.md</code>. Remove the <code>parseInt()</code> function and run the code. The output is <code>string 31</code> instead of <code>number 4</code>, but this is hardly a surprise to us:<br><img src="https://user-images.githubusercontent.com/10218864/35014056-3d72b6fa-fac4-11e7-8709-d66f6513ec40.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<p>Let's put together everything we discussed about the <code>syncContent()</code> method for our Chapter model:<br><code>server/models/Chapter.js</code> :</p>
<pre><code>static async syncContent({ book, data }) {
  const {
    title,
    excerpt = <span class="hljs-string">''</span>,
    isFree = <span class="hljs-keyword">false</span>,
    seoTitle = <span class="hljs-string">''</span>,
    seoDescription = <span class="hljs-string">''</span>,
  } = data.attributes;

  const { body, <span class="hljs-type">path</span> } = data;

  const chapter = await this.findOne({
    bookId: book.id,
    githubFilePath: <span class="hljs-type">path</span>,
  });

  let <span class="hljs-keyword">order</span>;

  <span class="hljs-keyword">if</span> (<span class="hljs-type">path</span> === <span class="hljs-string">'introduction.md'</span>) {
    <span class="hljs-keyword">order</span> = <span class="hljs-number">1</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">order</span> = parseInt(<span class="hljs-type">path</span>.match(/[<span class="hljs-number">0</span><span class="hljs-number">-9</span>]+/), <span class="hljs-number">10</span>) + <span class="hljs-number">1</span>;
  }

  // <span class="hljs-number">1.</span> <span class="hljs-keyword">if</span> chapter document does <span class="hljs-keyword">not</span> exist - <span class="hljs-keyword">create</span> slug <span class="hljs-keyword">and</span> <span class="hljs-keyword">create</span> document <span class="hljs-keyword">with</span> <span class="hljs-keyword">all</span> parameters

  // <span class="hljs-number">2.</span> <span class="hljs-keyword">else</span>, define modifier <span class="hljs-keyword">for</span> parameters: content, htmlContent, sections, excerpt, htmlExcerpt, isFree, <span class="hljs-keyword">order</span>, seoTitle, seoDescription

  // <span class="hljs-number">3.</span> <span class="hljs-keyword">update</span> existing document <span class="hljs-keyword">with</span> modifier
}</code></pre><p>Let's discuss the missing code snippets.</p>
<ol>
<li><p>To create a new chapter document, we use Mongoose's <code>Model.create()</code> <a target="_blank" href="http://mongoosejs.com/docs/api.html#model_Model.create" rel="noopener noreferrer">method</a>. Check up how we did it for the User model at <code>server/models/User.js</code>. Before we call this method, we have to call and <code>await</code> for <code>generateSlug(Model, title)</code> to generate the chapter's <code>slug</code> from its <code>title</code>:</p>
<pre><code>if (!chapter) {
<span class="hljs-symbol"> const slug = await generateSlug(this, title, { bookId:</span> book._id })<span class="hljs-comment">;</span>

 <span class="hljs-keyword">return</span> this.create({
<span class="hljs-symbol">   bookId:</span> book._id,
<span class="hljs-symbol">   githubFilePath:</span> path,
<span class="hljs-built_in">   title,</span>
<span class="hljs-built_in">   slug,</span>
<span class="hljs-built_in">   isFree,</span>
<span class="hljs-built_in">   content,</span>
<span class="hljs-built_in">   htmlContent,</span>
<span class="hljs-built_in">   sections,</span>
<span class="hljs-built_in">   excerpt,</span>
<span class="hljs-built_in">   htmlExcerpt,</span>
<span class="hljs-built_in">   order,</span>
<span class="hljs-built_in">   seoTitle,</span>
<span class="hljs-built_in">   seoDescription,</span>
<span class="hljs-symbol">   createdAt:</span> <span class="hljs-keyword">new</span> Date(),
 })<span class="hljs-comment">;</span>
}</code></pre><p>Take a look at <code>server/utils/slugify.js</code> if you need to remember how the <code>generateSlug(Model, name, filter = {})</code> function works.</p>
</li>
<li><p>When a chapter document already exists and our Admin user calls <code>syncContent()</code> on the Chapter model - we want to update (as in, overwrite) the chapter's parameters. Let's define a <code>modifier</code> object as:</p>
<pre><code>const modifier = {
<span class="hljs-built_in"> content,</span>
<span class="hljs-built_in"> htmlContent,</span>
<span class="hljs-built_in"> sections,</span>
<span class="hljs-built_in"> excerpt,</span>
<span class="hljs-built_in"> htmlExcerpt,</span>
<span class="hljs-built_in"> isFree,</span>
<span class="hljs-built_in"> order,</span>
<span class="hljs-built_in"> seoTitle,</span>
<span class="hljs-built_in"> seoDescription,</span>
}<span class="hljs-comment">;</span></code></pre><p>In case the book's <code>title</code> is changed, we should re-generate <code>slug</code> and extend our <code>modifier</code> object with <code>title</code> and <code>slug</code> parameters:</p>
<pre><code><span class="hljs-keyword">if</span> (<span class="hljs-built_in">title</span> !== chapter.<span class="hljs-built_in">title</span>) {
 modifier.<span class="hljs-built_in">title</span> = <span class="hljs-built_in">title</span>;
 modifier.slug = await generateSlug(this, <span class="hljs-built_in">title</span>, {
<span class="hljs-function">   bookId: <span class="hljs-title">chapter.bookId</span>,
 });
}</span></code></pre></li>
<li><p>Mongoose's method <a target="_blank" href="http://mongoosejs.com/docs/api.html#model_Model.updateOne" rel="noopener noreferrer">Model.updateOne()</a> updates a single chapter document that has a matching <code>_id</code>:</p>
<pre>return this.updateOne({ _id: chapter._id }, { $set: modifier });</pre>

<p>As you know from writing the User model, the <a target="_blank" href="https://docs.mongodb.com/manual/reference/operator/update/set/index.html" rel="noopener noreferrer">$set</a> operator replaces a parameter's value with a specified value.</p>
</li>
</ol>
<p>Paste the three code snippets above, and we get <code>syncContent()</code> static method:</p>
<pre><code>static async syncContent({ book, <span class="hljs-keyword">data</span> }) {
  <span class="hljs-keyword">const</span> {
    title,
    excerpt = <span class="hljs-string">''</span>,
    isFree = <span class="hljs-literal">false</span>,
    seoTitle = <span class="hljs-string">''</span>,
    seoDescription = <span class="hljs-string">''</span>,
  } = <span class="hljs-keyword">data</span>.attributes;

  <span class="hljs-keyword">const</span> { body, path } = <span class="hljs-keyword">data</span>;

  <span class="hljs-keyword">const</span> chapter = await <span class="hljs-keyword">this</span>.findOne({
    bookId: book.id,
    githubFilePath: path,
  });

  let order;

  <span class="hljs-keyword">if</span> (path === <span class="hljs-string">'introduction.md'</span>) {
    order = <span class="hljs-number">1</span>;
  } <span class="hljs-keyword">else</span> {
    order = parseInt(path.match(/[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+/), <span class="hljs-number">10</span>) + <span class="hljs-number">1</span>;
  }

  <span class="hljs-keyword">if</span> (!chapter) {
    <span class="hljs-keyword">const</span> slug = await generateSlug(<span class="hljs-keyword">this</span>, title, { bookId: book._id });

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.create({
      bookId: book._id,
      githubFilePath: path,
      title,
      slug,
      isFree,
      content,
      htmlContent,
      sections,
      excerpt,
      htmlExcerpt,
      order,
      seoTitle,
      seoDescription,
      createdAt: new Date(),
    });
  }

  <span class="hljs-keyword">const</span> modifier = {
    content,
    htmlContent,
    sections,
    excerpt,
    htmlExcerpt,
    isFree,
    order,
    seoTitle,
    seoDescription,
  };

  <span class="hljs-keyword">if</span> (title !== chapter.title) {
    modifier.title = title;
    modifier.slug = await generateSlug(<span class="hljs-keyword">this</span>, title, {
      bookId: chapter.bookId,
    });
  }

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.updateOne({ _id: chapter._id }, { $<span class="hljs-keyword">set</span>: modifier });
}</code></pre><p><em>Important</em> - remember to add this static method above to our Chapter model at <code>server/models/Chapter.js</code>. Add it after the <code>static async getBySlug()</code> static method.</p>
<p>Make sure you have all required imports for the <code>server/models/Chapter.js</code> file:</p>
<pre><code><span class="hljs-keyword">import</span> mongoose <span class="hljs-keyword">from</span> <span class="hljs-string">'mongoose'</span>;

<span class="hljs-keyword">import</span> generateSlug <span class="hljs-keyword">from</span> <span class="hljs-string">'../utils/slugify'</span>;
<span class="hljs-keyword">import</span> Book <span class="hljs-keyword">from</span> <span class="hljs-string">'./Book'</span>;</code></pre><p>In the code for the static method <code>syncContent()</code> of our Chapter model, we <em>have not</em> defined markdown content <code>content</code>, HTML content <code>htmlContent</code>, and <code>sections</code>. Let's discuss these parameters in the next section.</p>
<h2 class="chapter-section" style="color: #FFF; font-weight: 400;">
        <a name="markdown-to-html" href="#markdown-to-html" style="color: #FFF;"> 
          <i class="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer; color: FFF;">
            link
          </i>
        </a>
        <span class="section-anchor" name="markdown-to-html">
          Markdown to HTML
        </span>
      </h2><p>In the previous section, we defined:</p>
<pre>const { body, path } = data;</pre>

<p><code>body</code> (defined as <code>data.body</code>) is the markdown content of <code>.md</code> file or markdown content of a chapter (<code>chapter.content</code>). In other words:</p>
<pre>const content = body</pre>

<p>Once we have <code>chapter.content</code>, we save it to our database with the <code>syncContent()</code> static method of our Chapter model. Markdown <code>content</code> is nice, and you probably like using <a target="_blank" href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet" rel="noopener noreferrer">Github markdown</a>. We use markdown <code>content</code> to compare content on our database with content on Github, then decide whether we should update the content on our database or not. However, we cannot render markdown <code>content</code> directly on the browser.</p>
<p>To render on the browser, we need to convert markdown <code>content</code> to HTML <code>htmlContent</code>. The <a target="_blank" href="https://www.npmjs.com/package/marked" rel="noopener noreferrer">marked</a> package is a markdown parser and does exactly that. In other words, when we write <code>**some text**</code>, <code>marked</code> can convert it into <code>&lt;b&gt;some text&lt;/b&gt;</code>, and a user will see <strong>some text</strong> on his/her browser.</p>
<p>Marked is straigforward to use. In our case, we will parse chapter content with:<br><code>marked(content)</code></p>
<p>We can configure <code>marked</code> and modify rules that specify how <code>marked</code> renders some elements of markdown. You can <a target="_blank" href="https://www.npmjs.com/package/marked#overriding-renderer-methods" rel="noopener noreferrer">configure</a> <code>marked</code> renderer with <code>new marked.Renderer()</code>. For example, we would like every external link in our app to have these attributes: </p><pre>rel="noopener noreferrer" target="_blank"</pre> <p></p>
<p>Customizing <code>renderer</code> looks like:</p>
<pre><code><span class="hljs-keyword">const</span> renderer = <span class="hljs-keyword">new</span> marked.Renderer();

renderer.link = <span class="hljs-function">(<span class="hljs-params">href, title, text</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> t = title ? <span class="hljs-string">` title="<span class="hljs-subst">${title}</span>"`</span> : <span class="hljs-string">''</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;a target="_blank" href="<span class="hljs-subst">${href}</span>" rel="noopener noreferrer"<span class="hljs-subst">${t}</span>&gt;<span class="hljs-subst">${text}</span>&lt;/a&gt;`</span>;
};

marked.setOptions({
  renderer,
});</code></pre><p>The <code>marked</code> package does not come with default highlighting of code. To highlight contents in the <code>&lt;code&gt;</code> tag, <code>marked</code> offers <a target="_blank" href="https://www.npmjs.com/package/marked#highlight" rel="noopener noreferrer">multiple options</a>. We will use the <em>synchronous</em> example that uses the <a target="_blank" href="https://www.npmjs.com/package/highlight.js" rel="noopener noreferrer"><code>highlight.js</code> package</a>. This package works with any markup and detects language automatically.</p>
<p>After importing <code>hljs</code> from the <code>highlight.js</code> package, we set our <code>marked</code> options with <code>marked.setOptions()</code> (see <a target="_blank" href="https://www.npmjs.com/package/marked#usage" rel="noopener noreferrer">usage docs</a>):</p>
<pre><code>marked.setOptions({
  renderer,
  breaks:<span class="hljs-built_in"> true</span>,
  highlight(code,<span class="hljs-built_in"> lang</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">!lang</span>) {
      <span class="hljs-keyword">return</span> hljs.highlightAuto(code).<span class="hljs-keyword">value</span>;
    }

    <span class="hljs-keyword">return</span> hljs.highlight<span class="hljs-built_in">(lang</span>, code).<span class="hljs-keyword">value</span>;
  },
});</code></pre><p>If a language (<code>lang</code>) is specified, we pass it to <code>hljs.highlightAuto()</code>. If not specified, we rely on automatic detection.</p>
<p>We also specified <code>breaks: true</code>, so <code>marked</code> recognizes and adds line breaks.</p>
<p>In <a target="_blank" href="https://builderbook.org/books/builder-book/book-and-chapter-models-internal-api-render-chapter#testing" rel="noopener noreferrer">Chapter 5, section Testing</a>, we tested rendering of <code>htmlContent</code> on our <code>ReadChapter</code> page. We briefly discussed HTML elements with class names that start with <code>hljs</code>. Now you know where these class names come from - <code>marked</code> adds classes to text inside <code>&lt;pre&gt;</code> and <code>&lt;code&gt;</code> tags to highlight that text. In our case, <code>marked</code> recognizes code to be JavaScript and adds class name and highlights accordingly.</p>
<p>Besides customizing <code>link</code>, we would like to customize images with:</p>
<pre><code>renderer.image = href =&gt; `&lt;img
  <span class="hljs-attribute">src</span>=<span class="hljs-string">"<span class="hljs-variable">${href}</span>"</span>
  <span class="hljs-attribute">style</span>=<span class="hljs-string">"border: 1px solid #ddd;"</span>
  <span class="hljs-attribute">width</span>=<span class="hljs-string">"100%"</span>
  <span class="hljs-attribute">alt</span>=<span class="hljs-string">"Builder Book"</span>
&gt;`;</code></pre><p>We want all images to fit inside the page (<code>width="100%"</code>) and have a border around them (<code>style="border: 1px solid #ddd;"</code>).</p>
<p>Finally, we want to customize the conversion of headings, in particular <code>##</code> (<code>&lt;h2&gt;</code>) and <code>####</code> (<code>&lt;h4&gt;</code>):</p>
<pre><code>renderer.heading = (<span class="hljs-type">text</span>, <span class="hljs-keyword">level</span>) =&gt; {
  const escapedText = <span class="hljs-type">text</span>
    .trim()
    .toLowerCase()
    .replace(/[^\w]+/g, <span class="hljs-string">'-'</span>);

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">level</span> === <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">return</span> `&lt;h${<span class="hljs-keyword">level</span>} <span class="hljs-keyword">class</span>="chapter-section" style="color: #222; font-weight: 400;"&gt;
      &lt;a
        <span class="hljs-keyword">class</span>="section-anchor"
        <span class="hljs-type">name</span>="${escapedText}"
        href="#${escapedText}"
        style="color: #222;"
      &gt; 
        &lt;i <span class="hljs-keyword">class</span>="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer;"&gt;link&lt;/i&gt;
      &lt;/a&gt;
      ${<span class="hljs-type">text</span>}
    &lt;/h${<span class="hljs-keyword">level</span>}&gt;`;
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">level</span> === <span class="hljs-number">4</span>) {
    <span class="hljs-keyword">return</span> `&lt;h${<span class="hljs-keyword">level</span>} style="color: #222;"&gt;
      &lt;a
        <span class="hljs-type">name</span>="${escapedText}"
        href="#${escapedText}"
        style="color: #222;"
      &gt;
        &lt;i <span class="hljs-keyword">class</span>="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer;"&gt;link&lt;/i&gt;
      &lt;/a&gt;
      ${<span class="hljs-type">text</span>}
    &lt;/h${<span class="hljs-keyword">level</span>}&gt;`;
  }

  <span class="hljs-keyword">return</span> `&lt;h${<span class="hljs-keyword">level</span>} style="color: #222; font-weight: 400;"&gt;${<span class="hljs-type">text</span>}&lt;/h${<span class="hljs-keyword">level</span>}&gt;`;
};</code></pre><p>Notice that we added a hyperlinked Material icon in front of the heading's text:</p>
<pre><i class="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer;">link</i></pre>

<p>This icon loads from Google CDN, which you may recall from Chapter 1 when <a target="_blank" href="https://builderbook.org/books/builder-book/app-structure-next-js-hoc-material-ui-server-side-rendering-styles#document" rel="noopener noreferrer">customizing <code>&lt;Document&gt;</code></a>. Open <code>pages/_document.js</code> - we added the following <code>&lt;link&gt;</code> tag to the <code>&lt;Head&gt;</code> section of our custom document:</p>
<pre><code>&lt;link
  <span class="hljs-attribute">rel</span>=<span class="hljs-string">"stylesheet"</span>
  <span class="hljs-attribute">href</span>=<span class="hljs-string">"https://fonts.googleapis.com/icon?family=Material+Icons"</span>
/&gt;</code></pre><p>We want this icon in front of the heading text to have a unique link, so users can share links to particular sections or subsections (<code>href="#${escapedText}")</code>) of a chapter. We also want the page to scroll to an anchor (<code>name="${escapedText}"</code>) when a user clicks the hyperlinked icon.</p>
<p>We've applied <code>class="chapter-section"</code> to our <code>&lt;h2&gt;</code> heading. We will use this class in Chapter 7 to detect an in-view section and highlight the corresponding section inside our <code>Table of Content</code>.</p>
<p>Converting markdown with <code>marked</code> works well with the exception of <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Glossary/Entity" rel="noopener noreferrer">HTML entities</a>. For example, the <em>entity</em> <code>"</code> stands for <em>character</em> <code>"</code>. Github <em>encodes</em> characters into entities. And we have to <em>decode</em> entities <em>back</em> into characters before we show content to the users in our web app. We will use the <code>he</code> package to achieve that. This package provides us with both <code>he.encode()</code> and <code>he.decode()</code> methods. We need to use the latter.</p>
<p>To convert markdown to HTML, we will use:</p>
<pre>marked(he.decode(chapter.content))</pre>
<p>instead of:</p>
<pre>marked(content);</pre>


<p>We've written a lot of code related to customization of <code>marked</code>. Let's put it all together inside a <code>markdownToHtml()</code> function. This function will take markdown content (<code>markdownToHtml(content)</code>) as an argument and output HTML content (<code>return marked(he.decode(content))</code>):</p>
<pre><code><span class="hljs-keyword">function</span> markdownToHtml(content) {
  const renderer = <span class="hljs-built_in">new</span> marked.Renderer();

  renderer.link = (href, title, <span class="hljs-type">text</span>) =&gt; {
    const t = title ? ` title="${title}"` : <span class="hljs-string">''</span>;
    <span class="hljs-keyword">return</span> `&lt;a target="_blank" href="${href}" rel="noopener noreferrer"${t}&gt;${<span class="hljs-type">text</span>}&lt;/a&gt;`;
  };

  renderer.image = href =&gt; `&lt;img
    src="${href}"
    style="border: 1px solid #ddd;"
    width="100%"
    alt="Builder Book"
  &gt;`;

  renderer.heading = (<span class="hljs-type">text</span>, <span class="hljs-keyword">level</span>) =&gt; {
    const escapedText = <span class="hljs-type">text</span>
      .trim()
      .toLowerCase()
      .replace(/[^\w]+/g, <span class="hljs-string">'-'</span>);

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">level</span> === <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">return</span> `&lt;h${<span class="hljs-keyword">level</span>} <span class="hljs-keyword">class</span>="chapter-section" style="color: #222; font-weight: 400;"&gt;
        &lt;a
          <span class="hljs-type">name</span>="${escapedText}"
          href="#${escapedText}"
          style="color: #222;"
        &gt; 
          &lt;i <span class="hljs-keyword">class</span>="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer;"&gt;link&lt;/i&gt;
        &lt;/a&gt;
        &lt;span <span class="hljs-keyword">class</span>="section-anchor" <span class="hljs-type">name</span>="${escapedText}"&gt;
          ${<span class="hljs-type">text</span>}
        &lt;/span&gt;
      &lt;/h${<span class="hljs-keyword">level</span>}&gt;`;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">level</span> === <span class="hljs-number">4</span>) {
      <span class="hljs-keyword">return</span> `&lt;h${<span class="hljs-keyword">level</span>} style="color: #222;"&gt;
        &lt;a
          <span class="hljs-type">name</span>="${escapedText}"
          href="#${escapedText}"
          style="color: #222;"
        &gt;
          &lt;i <span class="hljs-keyword">class</span>="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer;"&gt;link&lt;/i&gt;
        &lt;/a&gt;
        ${<span class="hljs-type">text</span>}
      &lt;/h${<span class="hljs-keyword">level</span>}&gt;`;
    }

    <span class="hljs-keyword">return</span> `&lt;h${<span class="hljs-keyword">level</span>} style="color: #222; font-weight: 400;"&gt;${<span class="hljs-type">text</span>}&lt;/h${<span class="hljs-keyword">level</span>}&gt;`;
  };

  marked.setOptions({
    renderer,
    breaks: <span class="hljs-keyword">true</span>,
    highlight(code, lang) {
      <span class="hljs-keyword">if</span> (!lang) {
        <span class="hljs-keyword">return</span> hljs.highlightAuto(code).<span class="hljs-keyword">value</span>;
      }

      <span class="hljs-keyword">return</span> hljs.highlight(lang, code).<span class="hljs-keyword">value</span>;
    },
  });

  <span class="hljs-keyword">return</span> marked(he.decode(content));
}</code></pre><p>To convert content from markdown to HTML:</p>
<pre>const htmlContent = markdownToHtml(content)</pre>

<p>To convert an excerpt from markdown to HTML:</p>
<pre>const htmlExcerpt = markdownToHtml(excerpt)</pre>


<p>Similar to <code>markdownToHtml(content)</code>, let's define a <code>getSections(content)</code> function. This function takes markdown content and outputs a <code>sections</code> array. This array contains sections for our Table of Contents - every <code>&lt;h2&gt;</code> tag inside the content becomes a section inside the Table of Contents:</p>
<pre><code><span class="hljs-keyword">function</span> getSections(content) {
  const renderer = <span class="hljs-built_in">new</span> marked.Renderer();

  const sections = [];

  renderer.heading = (<span class="hljs-type">text</span>, <span class="hljs-keyword">level</span>) =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">level</span> !== <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">return</span>;
    }

    const escapedText = <span class="hljs-type">text</span>
      .trim()
      .toLowerCase()
      .replace(/[^\w]+/g, <span class="hljs-string">'-'</span>);

    sections.push({ <span class="hljs-type">text</span>, <span class="hljs-keyword">level</span>, escapedText });
  };

  marked.setOptions({
    renderer,
  });

  marked(he.decode(content));

  <span class="hljs-keyword">return</span> sections;
}</code></pre><p>We hyperlink sections on our Table of Contents using <code>escapedText</code>, but more on this in Chapter 7.</p>
<p>To make a <code>sections</code> array:</p>
<pre>const sections = getSections(content)</pre>


<p>At this point, we can update our Chapter model (<code>server/models/Chapter.js</code>):</p>
<ol>
<li>Define <code>markdownToHtml(content)</code> and <code>getSections(content)</code> functions before <code>const mongoSchema = new Schema()</code></li>
<li>Add the following snippet to the <code>syncContent()</code> static method:<pre><code><span class="hljs-attribute">const content</span> = body;
<span class="hljs-attribute">const htmlContent</span> = markdownToHtml(content);
<span class="hljs-attribute">const htmlExcerpt</span> = markdownToHtml(excerpt);
<span class="hljs-attribute">const sections</span> = getSections(content);</code></pre>right after:<pre><code><span class="hljs-keyword">if</span> (path === <span class="hljs-string">'introduction.md'</span>) {
 order = <span class="hljs-number">1</span>;
} <span class="hljs-keyword">else</span> {
 order = parseInt(path.match(/[<span class="hljs-number">0</span><span class="hljs-number">-9</span>]+/), <span class="hljs-number">10</span>) + <span class="hljs-number">1</span>;
}</code></pre></li>
<li>Remember to import missing packages <code>marked</code>, <code>he</code> and <code>hljs</code>.</li>
</ol>
<p>Follow steps 1-3 to update our Chapter model, and you should get:<br><code>server/models/Chapter.js</code> :</p>
<pre><code><span class="hljs-comment">/* eslint-disable no-use-before-define */</span>

<span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
<span class="hljs-keyword">const</span> marked = <span class="hljs-built_in">require</span>(<span class="hljs-string">'marked'</span>);
<span class="hljs-keyword">const</span> he = <span class="hljs-built_in">require</span>(<span class="hljs-string">'he'</span>);
<span class="hljs-keyword">const</span> hljs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'highlight.js'</span>);
<span class="hljs-comment">// const Book = require('./Book');</span>
<span class="hljs-keyword">const</span> generateSlug = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../utils/slugify'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markdownToHtml</span>(<span class="hljs-params">content</span>) </span>{
  <span class="hljs-keyword">const</span> renderer = <span class="hljs-keyword">new</span> marked.Renderer();

  renderer.link = <span class="hljs-function">(<span class="hljs-params">href, title, text</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> t = title ? <span class="hljs-string">` title="<span class="hljs-subst">${title}</span>"`</span> : <span class="hljs-string">''</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;a target="_blank" href="<span class="hljs-subst">${href}</span>" rel="noopener noreferrer"<span class="hljs-subst">${t}</span>&gt;<span class="hljs-subst">${text}</span>&lt;/a&gt;`</span>;
  };

  renderer.image = <span class="hljs-function"><span class="hljs-params">href</span> =&gt;</span> <span class="hljs-string">`&lt;img
    src="<span class="hljs-subst">${href}</span>"
    style="border: 1px solid #ddd;"
    width="100%"
    alt="Builder Book"
  &gt;`</span>;

  renderer.heading = <span class="hljs-function">(<span class="hljs-params">text, level</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> escapedText = text
      .trim()
      .toLowerCase()
      .replace(<span class="hljs-regexp">/[^\w]+/g</span>, <span class="hljs-string">'-'</span>);

    <span class="hljs-keyword">if</span> (level === <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;h<span class="hljs-subst">${level}</span> class="chapter-section" style="color: #222; font-weight: 400;"&gt;
        &lt;a
          name="<span class="hljs-subst">${escapedText}</span>"
          href="#<span class="hljs-subst">${escapedText}</span>"
          style="color: #222;"
        &gt; 
          &lt;i class="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer;"&gt;link&lt;/i&gt;
        &lt;/a&gt;
        &lt;span class="section-anchor" name="<span class="hljs-subst">${escapedText}</span>"&gt;
          <span class="hljs-subst">${text}</span>
        &lt;/span&gt;
      &lt;/h<span class="hljs-subst">${level}</span>&gt;`</span>;
    }

    <span class="hljs-keyword">if</span> (level === <span class="hljs-number">4</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;h<span class="hljs-subst">${level}</span> style="color: #222;"&gt;
        &lt;a
          name="<span class="hljs-subst">${escapedText}</span>"
          href="#<span class="hljs-subst">${escapedText}</span>"
          style="color: #222;"
        &gt;
          &lt;i class="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer;"&gt;link&lt;/i&gt;
        &lt;/a&gt;
        <span class="hljs-subst">${text}</span>
      &lt;/h<span class="hljs-subst">${level}</span>&gt;`</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;h<span class="hljs-subst">${level}</span> style="color: #222; font-weight: 400;"&gt;<span class="hljs-subst">${text}</span>&lt;/h<span class="hljs-subst">${level}</span>&gt;`</span>;
  };

  marked.setOptions({
    renderer,
    breaks: <span class="hljs-literal">true</span>,
    highlight(code, lang) {
      <span class="hljs-keyword">if</span> (!lang) {
        <span class="hljs-keyword">return</span> hljs.highlightAuto(code).value;
      }

      <span class="hljs-keyword">return</span> hljs.highlight(lang, code).value;
    },
  });

  <span class="hljs-keyword">return</span> marked(he.decode(content));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSections</span>(<span class="hljs-params">content</span>) </span>{
  <span class="hljs-keyword">const</span> renderer = <span class="hljs-keyword">new</span> marked.Renderer();

  <span class="hljs-keyword">const</span> sections = [];
  renderer.heading = <span class="hljs-function">(<span class="hljs-params">text, level</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (level !== <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">const</span> escapedText = text
      .trim()
      .toLowerCase()
      .replace(<span class="hljs-regexp">/[^\w]+/g</span>, <span class="hljs-string">'-'</span>);

    sections.push({ text, level, escapedText });
  };

  marked.setOptions({
    renderer,
  });

  marked(he.decode(content));

  <span class="hljs-keyword">return</span> sections;
}

<span class="hljs-keyword">const</span> { Schema } = mongoose;

<span class="hljs-keyword">const</span> mongoSchema = <span class="hljs-keyword">new</span> Schema({
  bookId: {
    <span class="hljs-keyword">type</span>: Schema.Types.ObjectId,
    required: <span class="hljs-literal">true</span>,
  },
  isFree: {
    <span class="hljs-keyword">type</span>: <span class="hljs-built_in">Boolean</span>,
    required: <span class="hljs-literal">true</span>,
    <span class="hljs-keyword">default</span>: <span class="hljs-literal">false</span>,
  },
  githubFilePath: {
    <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span>,
  },
  title: {
    <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span>,
    required: <span class="hljs-literal">true</span>,
  },
  slug: {
    <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span>,
    required: <span class="hljs-literal">true</span>,
  },
  excerpt: {
    <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span>,
    <span class="hljs-keyword">default</span>: <span class="hljs-string">''</span>,
  },
  content: {
    <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span>,
    <span class="hljs-keyword">default</span>: <span class="hljs-string">''</span>,
    required: <span class="hljs-literal">true</span>,
  },
  htmlContent: {
    <span class="hljs-keyword">type</span>: <span class="hljs-built_in">String</span>,
    <span class="hljs-keyword">default</span>: <span class="hljs-string">''</span>,
    required: <span class="hljs-literal">true</span>,
  },
  createdAt: {
    <span class="hljs-keyword">type</span>: <span class="hljs-built_in">Date</span>,
    required: <span class="hljs-literal">true</span>,
  },
  order: {
    <span class="hljs-keyword">type</span>: <span class="hljs-built_in">Number</span>,
    required: <span class="hljs-literal">true</span>,
  },
  seoTitle: <span class="hljs-built_in">String</span>,
  seoDescription: <span class="hljs-built_in">String</span>,
});

<span class="hljs-keyword">class</span> ChapterClass {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> getBySlug({ bookSlug, chapterSlug, userId }) {
    <span class="hljs-keyword">const</span> book = <span class="hljs-keyword">await</span> Book.getBySlug({ slug: bookSlug, userId });
    <span class="hljs-keyword">if</span> (!book) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Book not found'</span>);
    }

    <span class="hljs-keyword">const</span> chapter = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.findOne({ bookId: book._id, slug: chapterSlug });

    <span class="hljs-keyword">if</span> (!chapter) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Chapter not found'</span>);
    }

    <span class="hljs-keyword">const</span> chapterObj = chapter.toObject();
    chapterObj.book = book;

    <span class="hljs-keyword">return</span> chapterObj;
  }

  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> syncContent({ book, data }) {
    <span class="hljs-keyword">const</span> {
      title,
      excerpt = <span class="hljs-string">''</span>,
      isFree = <span class="hljs-literal">false</span>,
      seoTitle = <span class="hljs-string">''</span>,
      seoDescription = <span class="hljs-string">''</span>,
    } = data.attributes;

    <span class="hljs-keyword">const</span> { body, path } = data;

    <span class="hljs-keyword">const</span> chapter = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.findOne({
      bookId: book.id,
      githubFilePath: path,
    });

    <span class="hljs-keyword">let</span> order;

    <span class="hljs-keyword">if</span> (path === <span class="hljs-string">'introduction.md'</span>) {
      order = <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
      order = <span class="hljs-built_in">parseInt</span>(path.match(<span class="hljs-regexp">/[0-9]+/</span>), <span class="hljs-number">10</span>) + <span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">const</span> content = body;
    <span class="hljs-keyword">const</span> htmlContent = markdownToHtml(content);
    <span class="hljs-keyword">const</span> htmlExcerpt = markdownToHtml(excerpt);
    <span class="hljs-keyword">const</span> sections = getSections(content);

    <span class="hljs-keyword">if</span> (!chapter) {
      <span class="hljs-keyword">const</span> slug = <span class="hljs-keyword">await</span> generateSlug(<span class="hljs-keyword">this</span>, title, { bookId: book._id });

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.create({
        bookId: book._id,
        githubFilePath: path,
        title,
        slug,
        isFree,
        content,
        htmlContent,
        sections,
        excerpt,
        htmlExcerpt,
        order,
        seoTitle,
        seoDescription,
        createdAt: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
      });
    }

    <span class="hljs-keyword">const</span> modifier = {
      content,
      htmlContent,
      sections,
      excerpt,
      htmlExcerpt
      isFree,
      order,
      seoTitle,
      seoDescription,
    };

    <span class="hljs-keyword">if</span> (title !== chapter.title) {
      modifier.title = title;
      modifier.slug = <span class="hljs-keyword">await</span> generateSlug(<span class="hljs-keyword">this</span>, title, {
        bookId: chapter.bookId,
      });
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.updateOne({ _id: chapter._id }, { $<span class="hljs-keyword">set</span>: modifier });
  }
}

mongoSchema.index({ bookId: <span class="hljs-number">1</span>, slug: <span class="hljs-number">1</span> }, { unique: <span class="hljs-literal">true</span> });
mongoSchema.index({ bookId: <span class="hljs-number">1</span>, githubFilePath: <span class="hljs-number">1</span> }, { unique: <span class="hljs-literal">true</span> });

mongoSchema.loadClass(ChapterClass);

<span class="hljs-keyword">const</span> Chapter = mongoose.model(<span class="hljs-string">'Chapter'</span>, mongoSchema);

<span class="hljs-built_in">module</span>.exports = Chapter;

<span class="hljs-keyword">const</span> Book = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./Book'</span>);</code></pre><p>We introduced <code>syncContent()</code> methods to Book and Chapter model. These methods use Github API methods to get or sync data from Github. So how do we trigger a sync event? We should let the Admin user initiate syncing with a button click. Each book should have some sort of <em>details</em> page that has a <em>Sync</em> button that an Admin clicks to sync content.</p>
<p>It's important to note that syncing content from Github is a slow process. First, our app calls <code>Book.syncContent()</code> method, which in turn loops through each chapter. For each chapter, app calls <code>Chapter.syncContent()</code> that sends server-to-server request to Github, waits for response, decodes content and saves it to our database. Since Node is single-threaded, any computationally intense task may block it for incoming requests. And this is exactly the case with syncing content from Github. You will notice that while app is syncing content, app will load pages with a noticeable delay.</p>
<p>It is possible to isolate slow requests (computationally intense tasks) into so called <code>forked</code> or <code>child</code> process which is a process that runs in parallel to <code>main</code> or <code>parent</code> Node process. That way main Node process stays <em>unblocked</em> and available for incoming requests while forked process deals with slow request. We implemented forked process for syncing content in our <a target="_blank" href="https://github.com/builderbook/builderbook/blob/master/server/api/admin.js" rel="noopener noreferrer">open source project</a>, find the line with <code>const sync = fork()</code>. Check the code out if you want to dive deeper into Node scalability. Also stay tuned for upcoming <a target="_blank" href="https://builderbook.org/tutorials" rel="noopener noreferrer">tutorials</a> about Node scalability.</p>
<p>In the next section, we introduce the remaining pages in our Admin dashboard: a page to create a book, a page to edit a book, and a detail page that has a button to sync content.</p>
<h2 class="chapter-section" style="color: #FFF; font-weight: 400;">
        <a name="admin-dashboard" href="#admin-dashboard" style="color: #FFF;"> 
          <i class="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer; color: FFF;">
            link
          </i>
        </a>
        <span class="section-anchor" name="admin-dashboard">
          Admin dashboard
        </span>
      </h2><p>At this point, our Book and Chapter models have all necessary static methods. Our Book model has <code>list()</code>, <code>getBySlug()</code>, <code>add()</code>, <code>edit()</code>, and <code>syncContent()</code> static methods. Our Chapter model has <code>getBySlug()</code> and <code>synContent</code>.</p>
<p>You'll notice that our Chapter model, unlike the Book model, does not have <code>add()</code> and <code>edit()</code> methods. That's because the Admin user creates and updates a <em>book</em> directly inside our web app. However, the Admin creates and updates a <em>chapter</em> on Github and syncs this content to our database with the <code>syncContent()</code> method. Thus, no need for <code>add()</code> and <code>edit()</code> methods in the Chapter model.</p>
<p>So far, we've only used the Book model's <code>list()</code> method to display a list of books on <code>pages/admin/index.js</code> and the Chapter model's <code>getBySlug()</code> method to display chapter data on <code>pages/public/read-chapter.js</code>. Remember that to test out these two pages, you had to <em>manually</em> insert documents to MongoDB. In this and the following subsection, we will discuss and add three more Admin pages and one Admin component:</p>
<ul>
<li><code>pages/admin/add-book.js</code></li>
<li><code>pages/admin/edit-book.js</code></li>
<li><code>pages/admin/book-detail.js</code></li>
<li><code>components/admin/EditBook.js</code></li>
</ul>
<p>The names of these pages are self-explanatory. The first page will allow us to create a book; second to edit a book (for example, edit price or Github repo); third page will show our Admin user some book data and a <code>Sync</code> button that syncs book content between Github and our database. The <code>EditBook.js</code> component will render a list of repos and let the Admin user pick a repo from which our app will get content for the book's chapters.</p>
<p>After adding these missing pages and corresponding Express routes and methods, we will test out the entire Admin flow, from book creation to content syncing.</p>
<p>Let's discuss the Admin's initial action and subsequent data flow in detail.</p>
<ol>
<li><p>For adding a new book, the data flow is:</p>
<ul>
<li>Admin clicks button on page <code>add-book.js</code> (at <code>pages/admin/add-book.js</code>) =&gt;</li>
<li>API method <code>addBook</code> (at <code>lib/api/admin.js</code>) sends POST request to server. Request's <code>body</code> has the book's data. =&gt;</li>
<li>Express route <code>router.post('/books/add')</code> (at <code>server/api/admin.js</code>) =&gt;</li>
<li>Static method <code>static async add()</code> (at <code>server/models/Book.js</code>) - <em>already done</em></li>
</ul>
<p><code>=&gt;</code> stands for <code>calls or triggers</code>: clicking a button <code>calls</code> a method, the method <code>calls</code> an Express route, and the route <code>calls</code> a static method.</p>
<p>We already wrote the static methods <code>list()</code>, <code>getBySlug</code>, <code>add()</code>, <code>edit()</code>, and <code>syncContent</code> for our Book and Chapter models. Thus we added the note <em><code>already done</code></em> to the last step (static method step).</p>
</li>
<li><p>The Admin user should be able to edit a book (for example, edit the price). Here is the initial Admin action and data flow: </p>
<ul>
<li>Admin clicks button on page <code>edit-book.js</code> (at <code>pages/admin/edit-book.js</code>) =&gt;</li>
<li>API method <code>editBook</code> (at <code>lib/api/admin.js</code>) sends POST request to server. Request's <code>body</code> has the book's data. =&gt;</li>
<li>Express route <code>router.post('/books/edit')</code> (at <code>server/api/admin.js</code>) =&gt;</li>
<li>Static method <code>static async edit()</code> (at <code>server/models/Book.js</code>) - <em>already done</em></li>
</ul>
</li>
<li><p>We want the Admin user to be able to see a book's parameters at <code>pages/admin/book-detail.js</code>. Instead of clicking a button, the Admin simply loads the page to call the API method <code>getBookDetail</code>:</p>
<ul>
<li>Admin loads page <code>book-detail.js</code> page (at <code>pages/admin/book-detail.js</code>) =&gt;</li>
<li>API method <code>getBookDetail</code> (at <code>lib/api/admin.js</code>) =&gt;</li>
<li>Express route <code>router.get('/books/detail/:slug')</code> (at <code>server/api/admin.js</code>) =&gt;</li>
<li>Static method <code>static async getBySlug()</code> (at <code>server/models/Book.js</code>) - <em>already done</em></li>
</ul>
</li>
<li><p>On the <code>book-detail.js</code> page, we will have a <code>Sync</code> button. The Admin triggers the <code>syncBookContent</code> API method by clicking this button.</p>
<ul>
<li>Admin clicks <code>Sync</code> button on <code>book-detail.js</code> page (at <code>pages/admin/book-detail.js</code>) =&gt;</li>
<li>API method <code>syncBookContent</code> (at <code>lib/api/admin.js</code>) =&gt;</li>
<li>Express route <code>router.post('/books/sync-content')</code> (at <code>server/api/admin.js</code>) =&gt;</li>
<li>Static method <code>static async syncContent()</code> (at <code>server/models/Book.js</code>) - <em>already done</em></li>
</ul>
</li>
<li><p>There is one more API method that we need to add: <code>getGithubRepos</code>. None of the Admin pages directly contain this method. In fact, we call it from the <code>EditBook.js</code> component at <code>components/admin/EditBook.js</code>. We import this component into two Admin pages: <code>add-book.js</code> and <code>edit-book.js</code>. </p>
<p>From the method's name, <code>getGithubRepos</code>, you can understand that this method sends a request to our server, and in return, our server executes the <code>getRepos()</code> API method for Github. As a final outcome of this chain of events, our <code>EditBook.js</code> component receives a list of repos. Our Admin user is able to see this list on the <code>add-book.js</code> and <code>edit-book.js</code> pages. The Admin picks one repo from this list, thus passing a book's parameter <code>githubRepo</code> to the <code>addBook</code> and <code>editBook</code> API methods.</p>
<ul>
<li>Admin loads either <code>add-book.js</code> or <code>edit-book.js</code> page, this loads <code>EditBook.js</code> component (at <code>components/admin/EditBook.js</code>) =&gt;</li>
<li>API method <code>getGithubRepos</code> (at <code>lib/api/admin.js</code>) =&gt;</li>
<li>Express route <code>router.get('/github/repos')</code> (at <code>server/api/admin.js</code>) =&gt;</li>
<li>Github's API method <code>getRepos()</code>  (at <code>server/github.js</code>) - <em>already done</em></li>
</ul>
</li>
</ol>
<h4 style="color: #FFF;">
        <a name="express-routes" href="#express-routes" style="color: #FFF;">
          <i class="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer; color: FFF;">
              link
            </i>
        </a>
        Express routes
      </h4><p>In this subsection, we will add the following five routes to our Admin code at <code>server/api/admin.js</code>:</p>
<ol>
<li><code>router.post('/books/add')</code></li>
<li><code>router.post('/books/edit')</code></li>
<li><code>router.get('/books/detail/:slug')</code></li>
<li><code>router.post('/books/sync-content')</code></li>
<li><code>router.get('/github/repos')</code></li>
</ol>
<ol>
<li><p>The Express route <code>router.post('/books/add')</code> gets the book's data (<code>name</code>, <code>price</code>, <code>githubRepo</code>) from the request's <code>body</code>. This route calls the static method <code>add()</code> in our Book model to create a new book.<br><code>server/api/admin.js</code> :</p>
<pre><code>router.post('/books/add', async<span class="hljs-function"> (<span class="hljs-params">req</span>, <span class="hljs-params">res</span>) =&gt;</span> {
 <span class="hljs-keyword">try</span> {
   const book = await <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Book</span>.</span></span>add(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>assign({ userId: req.user.id }, req.body));
   res.json(book);
 } catch (err) {
   logger.error(err);
   res.json({ error: err.message<span class="hljs-operator"> || </span>err.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span> });
 }
});</code></pre><p>The code inside this route <em>does not</em> have to return a <code>book</code> object to the client (browser). We use this Express route to create a new book. However, after a new book is created, we want to do two things:</p>
<ul>
<li>sync the book content with the <code>syncContent()</code> function that requires a <code>book._id</code> from the newly created <code>book</code> object,</li>
<li>redirect user to <code>BookDetail</code> page and that requires having <code>book.slug</code> from the newly created <code>book</code> object.</li>
</ul>
<p>Thus, let's return <code>book</code> object to the client (browser) with <code>res.json(book)</code>.</p>
<p>An important note on POST requests.</p>
<p>Our server has to parse and decode a POST request's body <code>req.body</code>. We need to tell Express to use middleware that parses/decodes <code>application/json</code> format. We do so by using Express's package <a target="_blank" href="https://www.npmjs.com/package/body-parser" rel="noopener noreferrer">body-parser</a>.</p>
<p>Import <code>bodyParser</code> to <code>server/app.js</code>:</p>
<pre>import bodyParser from 'body-parser';</pre>

<p>Add the following line to <code>server/app.js</code> above the <code>const MongoStore = mongoSessionStore(session);</code> line:</p>
<pre>server.use(bodyParser.json());</pre>

<p>An alternative to using the external bodyParser package is to use internal Express middleware. To do so, remove the import code for bodyParser and replace the above line of code with:</p>
<pre>server.use(express.json());</pre>

<p>Both <code>bodyParser.json()</code> and <code>express.json()</code> return middlware that parses and decodes data JSON format from request's <code>body</code> and saves output in <code>req.body</code>. To reduce number of external packages, let's use <code>express.json()</code>.</p>
<p>To understand Express's body-parser in more detail, check out this <a target="_blank" href="https://medium.com/@adamzerner/how-bodyparser-works-247897a93b90" rel="noopener noreferrer">blog post</a>.</p>
</li>
<li><p>The Express route <code>router.post('/books/edit')</code> is very similar to <code>router.post('/books/add')</code>. But instead of returning <code>res.json(book)</code>, it should return an <em>edited</em> book object. This is the same book object that we created using the <code>add()</code> method explained above, but now the book has edited parameters (such as name, slug, price). We call this object <code>editedBook</code>.</p>
<p>Recall this code snippet from the static method <code>edit()</code> of our Book model (<code>server/models/Book.js</code>):</p>
<pre><code>const editedBook = await this.find<span class="hljs-constructor">OneAndUpdate( { <span class="hljs-params">_id</span>: <span class="hljs-params">id</span> }, { $<span class="hljs-params">set</span>: <span class="hljs-params">modifier</span> }, { <span class="hljs-params">fields</span>: '<span class="hljs-params">slug</span>', <span class="hljs-params">new</span>: <span class="hljs-params">true</span> } )</span>;

return editedBook;</code></pre><p>As you can see, the static method <code>edit()</code> returns a newly edited book object to the corresponding Express route. This object, <code>editedBook</code>, contains only two parameters: <code>_id</code> and <code>slug</code>. We need both of these parameters on the client to call our <code>syncContent()</code> API method and to redirect a user to a new <code>BookDetail</code> page (the URL of this page contains the edited book's <code>slug</code>).</p>
<p>Now let's write our Express route <code>router.post('/books/edit')</code> with the <code>editedBook</code> object.<br><code>server/api/admin.js</code> :</p>
<pre><code>router.<span class="hljs-keyword">post</span>('/books/<span class="hljs-keyword">edit</span>', async (req, res) =&gt; {
 try {
   <span class="hljs-keyword">const</span> editedBook = await Book.<span class="hljs-keyword">edit</span>(req.body);
   res.json(editedBook);
 } catch (<span class="hljs-keyword">err</span>) {
   res.json({ <span class="hljs-keyword">error</span>: <span class="hljs-keyword">err</span>.message || <span class="hljs-keyword">err</span>.<span class="hljs-keyword">toString</span>() });
 }
});</code></pre><p>Another note on POST requests.</p>
<p>For most POST requests that pass data to our server (to create/update data), the response <em>does not</em> have to return any actual data from our database to the client. For example, in the Express route above, we don't <em>have</em> to return a <code>book</code> object to the client (browser). However, the server <em>must</em> return a response in a <code>req</code>-<code>res</code> cycle.</p>
<p>We could have returned an object without data, such as <code>{ done: 1 }</code>. You can return whatever you want, for example <code>{ save: 1 }</code>. The reason that <em>we did</em> return an object with data (<code>editedBook</code>) is because we need the slug of the newly edited book (<code>editedBook.slug</code>) on the client. This slug is used to redirect the user to the <em>new</em> <code>BookDetail</code> page, which contains the book slug in its URL. If you choose not to redirect a user to the new <code>BookDetail</code> page, you can simply return <code>{ done: 1}</code> in the above Express route.</p>
</li>
<li><p>The Express route <code>router.get('/books/detail/:slug')</code> gets <code>slug</code> and is called by the <code>getBookDetail()</code> API method located in the <code>pages/admin/book-detail.js</code> page. <code>Book.getBySlug()</code>, inside this Express route, finds a book using <code>slug</code>. </p>
<p>Express uses <code>req.params</code> (<a target="_blank" href="https://builderbook.org/books/builder-book/book-and-chapter-models-internal-api-render-chapter#page" rel="noopener noreferrer">discussed before in Chapter 5</a>) to extract a parameter from the route with <code>req.params.slug</code>.<br><code>server/api/admin.js</code> :</p>
<pre><code>router.get('/books/detail/:slug', async<span class="hljs-function"> (<span class="hljs-params">req</span>, <span class="hljs-params">res</span>) =&gt;</span> {
 <span class="hljs-keyword">try</span> {
   const book = await <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Book</span>.</span></span>get<span class="hljs-constructor">BySlug({ <span class="hljs-params">slug</span>: <span class="hljs-params">req</span>.<span class="hljs-params">params</span>.<span class="hljs-params">slug</span> })</span>;
   res.json(book);
 } catch (err) {
   res.json({ error: err.message<span class="hljs-operator"> || </span>err.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span> });
 }
});</code></pre></li>
<li><p>Inside the <code>router.post('/books/sync-content')</code> route, we want to do two things:</p>
<ul>
<li>check if our Admin user has connected Github to our app</li>
<li>call the <code>syncContent()</code> static method from our Book model</li>
</ul>
<p>To check if the user has connected Github, we send the user's <code>_id</code> to our server as <code>req.user._id</code>. Then we use <code>req.user._id</code> to find this user with Mongoose's <code>Model.findById(id, [projection])</code> method. In <code>[projection]</code>, we specify values we'd like to return: <code>isGithubConnected</code> and <code>githubAccessToken</code>:<br><code>const user = await User.findById(req.user._id, 'isGithubConnected githubAccessToken');</code></p>
<p>We check if <code>isGithubConnected</code> is true <em>or</em> if <code>githubAccessToken</code> exists (not null). We throw an error if at least one of them is false or does not exist:</p>
<pre><code><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">user</span>.isGithubConnected || !<span class="hljs-keyword">user</span>.githubAccessToken) {
   res.json({ error: <span class="hljs-string">'Github is not connected'</span> });
   <span class="hljs-keyword">return</span>;
}</code></pre><p>Finally, by using the <code>try/catch</code> construct (as you did many times already), our Express route calls the Book model's <code>syncContent()</code> static method. This method takes two parameters (check up <code>server/models/Book.js</code>):</p>
<pre><code><span class="hljs-keyword">try</span> {
 await <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Book</span>.</span></span>sync<span class="hljs-constructor">Content({ <span class="hljs-params">id</span>: <span class="hljs-params">bookId</span>, <span class="hljs-params">githubAccessToken</span>: <span class="hljs-params">user</span>.<span class="hljs-params">githubAccessToken</span> })</span>;
 res.json({ <span class="hljs-keyword">done</span>: <span class="hljs-number">1</span> });
} catch (err) {
 logger.error(err);
 res.json({ error: err.message<span class="hljs-operator"> || </span>err.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span> });
}</code></pre><p>Put it all together and you get:<br><code>server/api/admin.js</code> :</p>
<pre><code>router.post('/books/sync-content', async<span class="hljs-function"> (<span class="hljs-params">req</span>, <span class="hljs-params">res</span>) =&gt;</span> {
 const { bookId } = req.body;

 const user = await <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">User</span>.</span></span>find<span class="hljs-constructor">ById(<span class="hljs-params">req</span>.<span class="hljs-params">user</span>.<span class="hljs-params">_id</span>, '<span class="hljs-params">isGithubConnected</span> <span class="hljs-params">githubAccessToken</span>')</span>;

 <span class="hljs-keyword">if</span> (!user.isGithubConnected<span class="hljs-operator"> || </span>!user.githubAccessToken) {
   res.json({ error: 'Github not connected' });
   return;
 }

 <span class="hljs-keyword">try</span> {
   await <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Book</span>.</span></span>sync<span class="hljs-constructor">Content({ <span class="hljs-params">id</span>: <span class="hljs-params">bookId</span>, <span class="hljs-params">githubAccessToken</span>: <span class="hljs-params">user</span>.<span class="hljs-params">githubAccessToken</span> })</span>;
   res.json({ <span class="hljs-keyword">done</span>: <span class="hljs-number">1</span> });
 } catch (err) {
   logger.error(err);
   res.json({ error: err.message<span class="hljs-operator"> || </span>err.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span> });
 }
});</code></pre><p>One thing to note - <code>syncContent()</code> needs <code>bookId</code>. In our request that we send to the server, we pass <code>bookId</code> in the request's body as <code>req.body.bookId</code>. We use ES6 destructuring syntax:</p>
<pre>const { bookId } = req.body;</pre></li>
<li><p>Inside the <code>router.get('/github/repos')</code> Express route, our goals are:</p>
<ul>
<li>check if our Admin user has connected Github to our web app</li>
<li>call the <code>getRepos</code> API method (defined in <code>server/github.js</code>), which returns a list of repos for a given user</li>
</ul>
<p>We just wrote code for checking if Github is connected in <code>router.post('/books/sync-content')</code>:</p>
<pre><code>const <span class="hljs-keyword">user</span> = await <span class="hljs-keyword">User</span>.findById(req.<span class="hljs-keyword">user</span>._id, <span class="hljs-string">'isGithubConnected githubAccessToken'</span>);

<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">user</span>.isGithubConnected || !<span class="hljs-keyword">user</span>.githubAccessToken) {
 res.json({ error: <span class="hljs-string">'Github is not connected'</span> });
 <span class="hljs-keyword">return</span>;
}</code></pre><p>Calling <code>getRepos()</code> with <code>try/catch</code> will look very similar to how we called <code>Book.syncContent()</code> with that same construct. Keep in mind that unlike <code>Book.syncContent()</code>, <code>getRepos()</code> requires only one parameter, <code>accessToken: user.githubAccessToken</code>:</p>
<pre><code> try {
   <span class="hljs-keyword">const</span> <span class="hljs-built_in">response</span> = await getRepos({ accessToken: user.githubAccessToken });
   res.json({ repos: <span class="hljs-built_in">response</span>.data });
 } catch (<span class="hljs-built_in">err</span>) {
   logger.<span class="hljs-keyword">error</span>(<span class="hljs-built_in">err</span>);
   res.json({ <span class="hljs-keyword">error</span>: <span class="hljs-built_in">err</span>.message || <span class="hljs-built_in">err</span>.toString() });
 }</code></pre><p>The only difference is that we wait (<code>await</code>) for a <code>response</code> with data (<code>response.data</code>) from the <code>getRepos()</code> API method. We send a response with data (list of repos) to the client:</p>
<pre>res.json({ repos: response.data });</pre>

<p>Put it together and you get:<br><code>server/api/admin.js</code> :</p>
<pre><code>router.get('/github/repos', async<span class="hljs-function"> (<span class="hljs-params">req</span>, <span class="hljs-params">res</span>) =&gt;</span> {
 const user = await <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">User</span>.</span></span>find<span class="hljs-constructor">ById(<span class="hljs-params">req</span>.<span class="hljs-params">user</span>.<span class="hljs-params">_id</span>, '<span class="hljs-params">isGithubConnected</span> <span class="hljs-params">githubAccessToken</span>')</span>;

 <span class="hljs-keyword">if</span> (!user.isGithubConnected<span class="hljs-operator"> || </span>!user.githubAccessToken) {
   res.json({ error: 'Github is not connected' });
   return;
 }

 <span class="hljs-keyword">try</span> {
   const response = await get<span class="hljs-constructor">Repos({ <span class="hljs-params">accessToken</span>: <span class="hljs-params">user</span>.<span class="hljs-params">githubAccessToken</span> })</span>;
   res.json({ repos: response.data });
 } catch (err) {
   logger.error(err);
   res.json({ error: err.message<span class="hljs-operator"> || </span>err.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span> });
 }
});</code></pre></li>
</ol>
<p>Add these five Express routes to <code>server/api/admin.js</code>, just below the <code>router.get('/books')</code> Express route.</p>
<p>Check your list of imports as well. It should be:</p>
<pre><code><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> Book = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../models/Book'</span>);
<span class="hljs-keyword">const</span> User = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../models/User'</span>);
<span class="hljs-keyword">const</span> { getRepos } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../github'</span>);
<span class="hljs-keyword">const</span> logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../logs'</span>);</code></pre><h4 style="color: #FFF;">
        <a name="api-methods" href="#api-methods" style="color: #FFF;">
          <i class="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer; color: FFF;">
              link
            </i>
        </a>
        API methods
      </h4><p>Alright, the static methods for our models and Express routes are done. Here we define five API methods:</p>
<ol>
<li><code>addBook</code></li>
<li><code>editBook</code></li>
<li><code>getBookDetail</code></li>
<li><code>syncBookContent</code></li>
<li><code>getGithubRepos</code></li>
</ol>
<p>Let's discuss, write, and add these API methods to <code>lib/api/admin.js</code>.</p>
<p>Open <code>lib/api/admin.js</code>. Remember how we implemented the <code>getBookList()</code> API method:<br><code>lib/api/admin.js</code> :</p>
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getBookList = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
  sendRequest(<span class="hljs-string">`<span class="hljs-subst">${BASE_PATH}</span>/books`</span>, {
    <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
  });</code></pre><p>In Chapter 5, we defined the <code>sendRequest()</code> function at <code>lib/api/sendRequest.js</code>. By default, this method is POST unless we specify <code>method: 'GET'</code>.</p>
<ol>
<li><p>The API method <code>addBook</code> takes <code>name</code>, <code>price</code>, and <code>githubRepo</code> specified by our Admin user and sends a POST request to the server at <code>/api/v1/admin/books/add</code>. POST is the default method, so we don't need to specify it inside <code>sendRequest()</code>. We do add the three book parameters (necessary for new book creation) to our request's <code>body</code>.<br><code>lib/api/admin.js</code> :</p>
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> addBook = <span class="hljs-function">(<span class="hljs-params">{ name, price, githubRepo }</span>) =&gt;</span>
sendRequest(<span class="hljs-string">`<span class="hljs-subst">${BASE_PATH}</span>/books/add`</span>, {
 <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify({ name, price, githubRepo }),
});</code></pre><p>Note that <code>${BASE_PATH}</code> for <code>lib/api/admin.js</code> is <code>/api/v1/admin</code>.</p>
</li>
<li><p>The API method <code>editBook</code> is very similar to <code>addBook</code> - it's a POST method that takes <code>name</code>, <code>price</code>, and <code>githubRepo</code>. In addition to these parameters, it takes a book's <code>id</code> to pass it to <code>findById</code> inside our static method <code>static async edit()</code> at <code>server/models/Book.js</code>.<br><code>lib/api/admin.js</code> :</p>
<pre><code>export const editBook = ({
<span class="hljs-built_in"> id,</span> name, price, githubRepo,
}) =&gt;
 sendRequest(`${BASE_PATH}/books/edit`, {
<span class="hljs-symbol">   body:</span> JSON.stringify({
<span class="hljs-built_in">     id,</span>
<span class="hljs-built_in">     name,</span>
<span class="hljs-built_in">     price,</span>
<span class="hljs-built_in">     githubRepo,</span>
   }),
})<span class="hljs-comment">;</span></code></pre></li>
<li><p>Unlike our <code>addBook</code> and <code>editBook</code> methods, the <code>getBookDetail</code> method sends a GET request. The server receives a <code>slug</code> parameter as part of the query string <code>/api/v1/admin/books/detail/${slug}</code>.<br><code>lib/api/admin.js</code> :</p>
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getBookDetail = <span class="hljs-function">(<span class="hljs-params">{ slug }</span>) =&gt;</span>
sendRequest(<span class="hljs-string">`<span class="hljs-subst">${BASE_PATH}</span>/books/detail/<span class="hljs-subst">${slug}</span>`</span>, {
 <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
});</code></pre></li>
<li><p>The API method <code>syncBookContent</code> sends a POST request to the server. This method adds <code>bookId</code> to the request's <code>body</code>.<br><code>lib/api/admin.js</code> :</p>
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> syncBookContent = <span class="hljs-function">(<span class="hljs-params">{ bookId }</span>) =&gt;</span>
 sendRequest(<span class="hljs-string">`<span class="hljs-subst">${BASE_PATH}</span>/books/sync-content`</span>, {
   <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify({ bookId }),
 });</code></pre></li>
<li><p>Finally, the API method <code>getGithubRepos</code> sends a GET request to the server. This method does not pass any of a book's parameters to the server. The HOC <code>withAuth.js</code> that wraps all Admin pages passes a user to the server, where our Express route <code>router.get('/github/repos')</code> uses <code>req.user._id</code> and <code>user.githubAccessToken</code> to find the user and get a list of his/her repos.</p>
<p>Add the following snippet to <code>lib/api/admin.js</code> :</p>
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getGithubRepos = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
 sendRequest(<span class="hljs-string">`<span class="hljs-subst">${BASE_PATH}</span>/github/repos`</span>, {
   <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
 });</code></pre></li>
</ol>
<p>Put the API methods from steps 1 to 5 into <code>lib/api/admin.js</code> as follows:<br><code>lib/api/admin.js</code> :</p>
<pre><code><span class="hljs-keyword">import</span> sendRequest <span class="hljs-keyword">from</span> <span class="hljs-string">'./sendRequest'</span>;

<span class="hljs-keyword">const</span> BASE_PATH = <span class="hljs-string">'/api/v1/admin'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> syncTOS = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> sendRequest(<span class="hljs-string">`<span class="hljs-subst">${BASE_PATH}</span>/sync-tos`</span>);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getBookList = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
  sendRequest(<span class="hljs-string">`<span class="hljs-subst">${BASE_PATH}</span>/books`</span>, {
    <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
  });

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getBookDetail = <span class="hljs-function">(<span class="hljs-params">{ slug }</span>) =&gt;</span>
  sendRequest(<span class="hljs-string">`<span class="hljs-subst">${BASE_PATH}</span>/books/detail/<span class="hljs-subst">${slug}</span>`</span>, {
    <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
  });

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> addBook = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span>
  sendRequest(<span class="hljs-string">`<span class="hljs-subst">${BASE_PATH}</span>/books/add`</span>, {
    <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(data),
  });

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> editBook = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span>
  sendRequest(<span class="hljs-string">`<span class="hljs-subst">${BASE_PATH}</span>/books/edit`</span>, {
    <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(data),
  });

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> syncBookContent = <span class="hljs-function">(<span class="hljs-params">{ bookId }</span>) =&gt;</span>
  sendRequest(<span class="hljs-string">`<span class="hljs-subst">${BASE_PATH}</span>/books/sync-content`</span>, {
    <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify({ bookId }),
  });

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getGithubRepos = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
  sendRequest(<span class="hljs-string">`<span class="hljs-subst">${BASE_PATH}</span>/github/repos`</span>, {
    <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
  });</code></pre><h4 style="color: #FFF;">
        <a name="admin-pages-and-components" href="#admin-pages-and-components" style="color: #FFF;">
          <i class="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer; color: FFF;">
              link
            </i>
        </a>
        Admin pages and components
      </h4><p>At this point, we've implemented static methods inside our models, Express routes, and API methods. Here we work on our last task - adding API methods to our pages and components.</p>
<p>We will discuss components and pages in this order:</p>
<ol>
<li>Component <code>components/adminEditBook.js</code></li>
<li>Page <code>pages/admin/add-book.js</code></li>
<li>Page <code>pages/admin/edit-book.js</code></li>
<li>Page <code>pages/admin/book-detail.js</code></li>
</ol>
<ol>
<li><p>The component <code>EditBook</code> makes up most of the interface for our <code>add-book.js</code> and <code>edit-book.js</code> pages. Thus we should discuss how this component works before we go into pages.</p>
<p>Note that we've already built multiple pages and components with React and Material-UI. We discussed how to use <code>propTypes</code>, <code>defaultProps</code>, <code>constructor</code>, <code>state</code>, <code>getInitialProps()</code>, <code>componentDidMount</code>, and more. We won't repeat what you learned - we'll primarily discuss how to add API methods to pages and components.</p>
<p>The component <code>EditBook</code> is essentially a simple form with a <code>Save</code> button. When our Admin clicks <code>Save</code>, the form gets submitted, thereby triggering <code>onSubmit = (event) =&gt;</code>. This event passes <code>name</code>, <code>price</code>, and <code>githubRepo</code> to <code>this.state.book</code> with ES6 destructuring:</p>
<pre>const { name, price, githubRepo } = this.state.book;</pre>

<p>If all three parameters exist, then they are passed to the <code>onSave</code> function as <code>this.state.book</code>, and we call the <code>onSave</code> prop function (i.e. parameter of <code>props</code> object, <code>this.props.onSave</code>) with:</p>
<pre>this.props.onSave(this.state.book);</pre>

<p>One important purpose of this component is to call <code>getGithubRepos()</code> to get a list of repos. Our Admin user will select one Github repo out of this list to create a book. As always, we call the method only after our component mounts, using our favorite <code>async/await</code> and <code>try/catch</code> combo:</p>
<pre><code><span class="hljs-function">async <span class="hljs-title">componentDidMount</span><span class="hljs-params">()</span> </span>{
 <span class="hljs-keyword">try</span> {
   <span class="hljs-keyword">const</span> { repos } = <span class="hljs-function">await <span class="hljs-title">getGithubRepos</span><span class="hljs-params">()</span></span>;
   <span class="hljs-keyword">this</span>.setState({ repos }); <span class="hljs-comment">// eslint-disable-line</span>
 } <span class="hljs-keyword">catch</span> (err) {
   logger.<span class="hljs-keyword">error</span>(err);
 }
}</code></pre><p><code>constructor</code> sets an initial state with <code>book</code> and <code>repos</code> props (we discussed <code>constructor</code> in detail in <a target="_blank" href="https://builderbook.org/books/builder-book/server-database-session-header-and-menudrop-components#menudrop-component" rel="noopener noreferrer">Chapter 2</a> and <a target="_blank" href="https://builderbook.org/books/builder-book/book-and-chapter-models-internal-api-render-chapter#readchapter-page" rel="noopener noreferrer">Chapter 5</a>):</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(props)</span> <span class="hljs-comment">{
 super(props);

 this.state = {
   book: props.book || {}</span>,
   <span class="hljs-title">repos</span>:</span> [],
 };
}</code></pre><p>The form has three items: book name (<code>&lt;TextField&gt;</code>), book title (also <code>&lt;TextField&gt;</code>), and a dropdown list of repos (<code>&lt;Select&gt;</code> with <code>&lt;MenuItem&gt;</code>).</p>
<p>Put all this information about our <code>EditBook</code> component together:<br><code>components/admin/EditBook.js</code> :</p>
<pre><code>import React <span class="hljs-keyword">from</span> 'react';
import PropTypes <span class="hljs-keyword">from</span> 'prop-types';
import Button <span class="hljs-keyword">from</span> '@material-ui/core/Button';
import TextField <span class="hljs-keyword">from</span> '@material-ui/core/TextField';
import Input <span class="hljs-keyword">from</span> '@material-ui/core/Input';
import Select <span class="hljs-keyword">from</span> '@material-ui/core/Select';
import MenuItem <span class="hljs-keyword">from</span> '@material-ui/core/MenuItem';

import { getGithubRepos } <span class="hljs-keyword">from</span> '../../lib/api/admin';
import { styleTextField } <span class="hljs-keyword">from</span> '../../components/SharedStyles';
import notify <span class="hljs-keyword">from</span> '../../lib/notifier';
import logger <span class="hljs-keyword">from</span> '../../server/logs';

class EditBook extends React.Component {
 static propTypes = {
   book: PropTypes.shape({
     _id: PropTypes.string.isRequired,
   }),
   <span class="hljs-keyword">on</span>Save: PropTypes.func.isRequired,
 };

 static <span class="hljs-keyword">default</span>Props = {
   book: null,
 };

 constructor(props) {
   super(props);

   this.<span class="hljs-keyword">state</span> = {
     book: props.book || {},
     repos: [],
   };
 }

 async componentDidMount() {
   try {
     const { repos } = await getGithubRepos();
     this.<span class="hljs-built_in">set</span>State({ repos }); // eslint-disable-line
   } catch (err) {
     logger.error(err);
   }
 }

 <span class="hljs-keyword">on</span>Submit = (event) =&gt; {
   event.preventDefault();
   const { name, price, githubRepo } = this.<span class="hljs-keyword">state</span>.book;

   if (!name) {
     notify('Name is required');
     return;
   }

   if (!price) {
     notify('Price is required');
     return;
   }

   if (!githubRepo) {
     notify('Github repo is required');
     return;
   }

   this.props.<span class="hljs-keyword">on</span>Save(this.<span class="hljs-keyword">state</span>.book);
 };

 render() {
   return (
     <span class="hljs-variable">&lt;div style={{ padding: '10px 45px' }}&gt;</span>
       <span class="hljs-variable">&lt;form onSubmit={this.onSubmit}&gt;</span>
         <span class="hljs-variable">&lt;br /&gt;</span>
         <span class="hljs-variable">&lt;div&gt;</span>
           <span class="hljs-variable">&lt;TextField
             onChange={(event) =&gt;</span> {
               this.<span class="hljs-built_in">set</span>State({
                 book: Object.assign({}, this.<span class="hljs-keyword">state</span>.book, { name: event.target.value }),
               });
             }}
             value={this.<span class="hljs-keyword">state</span>.book.name}
             type=<span class="hljs-string">"text"</span>
             <span class="hljs-keyword">label</span>=<span class="hljs-string">"Book's title"</span>
             <span class="hljs-keyword">label</span>ClassName=<span class="hljs-string">"textFieldLabel"</span>
             style={styleTextField}
             required
           /&gt;
         &lt;/div&gt;
         <span class="hljs-variable">&lt;br /&gt;</span>
         <span class="hljs-variable">&lt;br /&gt;</span>
         <span class="hljs-variable">&lt;TextField
           onChange={(event) =&gt;</span> {
             this.<span class="hljs-built_in">set</span>State({
               book: Object.assign({}, this.<span class="hljs-keyword">state</span>.book, { price: Number(event.target.value) }),
             });
           }}
           value={this.<span class="hljs-keyword">state</span>.book.price}
           type=<span class="hljs-string">"number"</span>
           <span class="hljs-keyword">label</span>=<span class="hljs-string">"Book's price"</span>
           className=<span class="hljs-string">"textFieldInput"</span>
           style={styleTextField}
           step=<span class="hljs-string">"1"</span>
           required
         /&gt;
         <span class="hljs-variable">&lt;br /&gt;</span>
         <span class="hljs-variable">&lt;br /&gt;</span>
         <span class="hljs-variable">&lt;div&gt;</span>
           <span class="hljs-variable">&lt;span&gt;</span>Github repo: &lt;/span&gt;
           <span class="hljs-variable">&lt;Select
             value={this.state.book.githubRepo || ''}
             input={&lt;Input /&gt;</span>}
             <span class="hljs-keyword">on</span>Change={(event) =&gt; {
               this.<span class="hljs-built_in">set</span>State({
                 book: Object.assign({}, this.<span class="hljs-keyword">state</span>.book, { githubRepo: event.target.value }),
               });
             }}
           &gt;
             <span class="hljs-variable">&lt;MenuItem value=""&gt;</span>
               <span class="hljs-variable">&lt;em&gt;</span>-- choose github repo --&lt;/em&gt;
             &lt;/MenuItem&gt;
             {this.<span class="hljs-keyword">state</span>.repos.map(r =&gt; (
               <span class="hljs-variable">&lt;MenuItem value={r.full_name} key={r.id}&gt;</span>
                 {r.full_name}
               &lt;/MenuItem&gt;
             ))}
           &lt;/Select&gt;
         &lt;/div&gt;
         <span class="hljs-variable">&lt;br /&gt;</span>
         <span class="hljs-variable">&lt;br /&gt;</span>
         <span class="hljs-variable">&lt;Button raised type="submit"&gt;</span>
           Save
         &lt;/Button&gt;
       &lt;/form&gt;
     &lt;/div&gt;
   );
 }
}

export <span class="hljs-keyword">default</span> EditBook;</code></pre><p>We are done with the <code>EditBook</code> component. Now let's discuss pages.</p>
</li>
<li><p>The page <code>add-book.js</code> is straightforward. Most of this page's interface comes from the <code>EditBook</code> component. We need to achieve this: Admin <em>clicks</em> on the form's <code>Save</code> button to call the <code>addBook()</code> method and pass a book's <code>data</code> to this method. That's why we wrote an <code>addBookOnSave</code> function inside the <code>EditBook</code> component. Once our Admin clicks <code>Save</code>, the <code>EditBook</code> component does three things:</p>
<ul>
<li>submits the form</li>
<li>passes the book's <code>name</code>, <code>price</code>, and <code>githubRepo</code> (as <code>this.state.book</code>) to the <code>onSave</code> function</li>
<li>calls the <code>onSave</code> function</li>
</ul>
<p>We call <code>addBookOnSave()</code> with <code>&lt;EditBook onSave={this.addBookOnSave} /&gt;</code></p>
<p>To create a new book, we want the <code>addBookOnSave</code> function to call the API method <code>addBook()</code>. The API method <code>addBook()</code> returns a <code>book</code> object.</p>
<p>Then we wait for the API method <code>syncBookContent()</code> to sync content with Github. When done, we display success with <code>notify()</code> from <a target="_blank" href="https://builderbook.org/books/builder-book/testing-with-jest-debugging-with-winston-transactional-emails-in-app-notifications#in-app-notifications" rel="noopener noreferrer">Chapter 4</a>. Also we let the loading Nprogress bar finish with <code>NProgress.done()</code>.</p>
<p>At the end, our app should redirect the Admin to the <code>BookDetail</code> page (<code>pages/admin/book-detail.js</code>) with Next.js's <code>Router.push()</code> (<a target="_blank" href="https://github.com/zeit/next.js#imperatively" rel="noopener noreferrer">read more</a>):</p>
<pre><code>addBookOnSave = <span class="hljs-keyword">async</span> (data) =&gt; {
 NProgress.start();

 <span class="hljs-keyword">try</span> {
   <span class="hljs-keyword">const</span> book = <span class="hljs-keyword">await</span> addBook(data);
   notify(<span class="hljs-string">'Saved'</span>);
   <span class="hljs-keyword">try</span> {
     <span class="hljs-keyword">const</span> bookId = book._id;
     <span class="hljs-keyword">await</span> syncBookContent({ bookId });
     notify(<span class="hljs-string">'Synced'</span>);
     NProgress.done();
     Router.push(<span class="hljs-string">`/admin/book-detail?slug=<span class="hljs-subst">${book.slug}</span>`</span>, <span class="hljs-string">`/admin/book-detail/<span class="hljs-subst">${book.slug}</span>`</span>);
   } <span class="hljs-keyword">catch</span> (err) {
     notify(err);
     NProgress.done();
   }
 } <span class="hljs-keyword">catch</span> (err) {
   notify(err);
   NProgress.done();
 }
};</code></pre><p>We'll discuss and create the <code>BookDetail</code> page later in this chapter.</p>
<p>Note that <code>data</code> inside the <code>addBookOnSave = async (data)</code> function is <code>this.state.book</code>. This is because we defined our <code>onSave()</code> function as <code>onSave(this.state.book)</code> (see the <code>EditBook</code> component above), and we pointed <code>onSave()</code> to <code>addBookOnSave()</code>: <code>onSave={this.addBookOnSave}</code> (see above snippet). </p>
<p>Create an <code>AddBook</code> component and add the above code to it before <code>render()</code>:<br><code>pages/admin/add-book.js</code> :</p>
<pre><code><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">'next/router'</span>;
<span class="hljs-keyword">import</span> NProgress <span class="hljs-keyword">from</span> <span class="hljs-string">'nprogress'</span>;

<span class="hljs-keyword">import</span> withAuth <span class="hljs-keyword">from</span> <span class="hljs-string">'../../lib/withAuth'</span>;
<span class="hljs-keyword">import</span> EditBook <span class="hljs-keyword">from</span> <span class="hljs-string">'../../components/EditBook'</span>;
<span class="hljs-keyword">import</span> { addBook, syncBookContent } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../lib/api/admin'</span>;
<span class="hljs-keyword">import</span> notify <span class="hljs-keyword">from</span> <span class="hljs-string">'../../lib/notifier'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddBook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
 addBookOnSave = <span class="hljs-keyword">async</span> (data) =&gt; {
   NProgress.start();

   <span class="hljs-keyword">try</span> {
     <span class="hljs-keyword">const</span> book = <span class="hljs-keyword">await</span> addBook(data);
     notify(<span class="hljs-string">'Saved'</span>);
     <span class="hljs-keyword">try</span> {
       <span class="hljs-keyword">const</span> bookId = book._id;
       <span class="hljs-keyword">await</span> syncBookContent({ bookId });
       notify(<span class="hljs-string">'Synced'</span>);
       NProgress.done();
       Router.push(<span class="hljs-string">`/admin/book-detail?slug=<span class="hljs-subst">${book.slug}</span>`</span>, <span class="hljs-string">`/admin/book-detail/<span class="hljs-subst">${book.slug}</span>`</span>);
     } <span class="hljs-keyword">catch</span> (err) {
       notify(err);
       NProgress.done();
     }
   } <span class="hljs-keyword">catch</span> (err) {
     notify(err);
     NProgress.done();
   }
 };

 render() {
   <span class="hljs-keyword">return</span> (
     <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">padding:</span> '<span class="hljs-attr">10px</span> <span class="hljs-attr">45px</span>' }}&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">EditBook</span> <span class="hljs-attr">onSave</span>=<span class="hljs-string">{this.addBookOnSave}</span> /&gt;</span>
     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
   );
 }
}

export default withAuth(AddBook);</span></code></pre><p>The Admin has to wait a bit for the API method to return a response (with data for GET requests, without data for POST requests). Thus we use <code>NProgress.start();</code> before we call <code>await addBook()</code>, and we call <code>NProgress.done();</code> after it.</p>
</li>
<li><p>The page <code>edit-book.js</code> is a bit more complex than <code>add-book.js</code>. In addition to calling the API method <code>editBook()</code>, we have to display the book's current data with another API method, <code>getBookDetail()</code>. We do so:</p>
<ul>
<li><p>with Next.js's <code>getInitialProps()</code>:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">getInitialProps</span><span class="hljs-params">({ query })</span> </span>{
 <span class="hljs-keyword">return</span> { slug: query.slug };
}</code></pre></li>
<li><p>with our <code>getBookDetail()</code> API method inside the <code>componentDidMount</code> lifecycle hook:</p>
<pre><code>async component<span class="hljs-constructor">DidMount()</span> {
 <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NProgress</span>.</span></span>start<span class="hljs-literal">()</span>;

 <span class="hljs-keyword">try</span> {
   const book = await get<span class="hljs-constructor">BookDetail({ <span class="hljs-params">slug</span>: <span class="hljs-params">this</span>.<span class="hljs-params">props</span>.<span class="hljs-params">slug</span> })</span>;
   this.set<span class="hljs-constructor">State({ <span class="hljs-params">book</span> })</span>; <span class="hljs-comment">// eslint-disable-line</span>
   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NProgress</span>.</span></span><span class="hljs-keyword">done</span><span class="hljs-literal">()</span>;
 } catch (err) {
   this.set<span class="hljs-constructor">State({ <span class="hljs-params">error</span>: <span class="hljs-params">err</span>.<span class="hljs-params">message</span> <span class="hljs-operator">||</span> <span class="hljs-params">err</span>.<span class="hljs-params">toString</span>()</span> }); <span class="hljs-comment">// eslint-disable-line</span>
   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NProgress</span>.</span></span><span class="hljs-keyword">done</span><span class="hljs-literal">()</span>;
 }
}</code></pre></li>
<li><p>and by passing the <code>book</code> prop to our <code>EditBook</code> component with <code>&lt;EditBookComp book={book} /&gt;</code></p>
</li>
</ul>
<p>Next, we need to make sure that when our Admin clicks the <code>Save</code> button, we call the API method <code>editBook()</code>. We make sure that after form submission, the <code>onSave</code> function points to the internal <code>editBookOnSave</code> function: <code>&lt;EditBookComp onSave={this.editBookOnSave} book={book} /&gt;</code></p>
<p>We call the <code>editBook()</code> API method inside the <code>editBook()</code> function as follows:</p>
<pre><code>editBookOnSave = <span class="hljs-keyword">async</span> (data) =&gt; {
 <span class="hljs-keyword">const</span> { book } = <span class="hljs-keyword">this</span>.state;
 NProgress.start();

 <span class="hljs-keyword">try</span> {
   <span class="hljs-keyword">const</span> editedBook = <span class="hljs-keyword">await</span> editBook({ ...data, <span class="hljs-attr">id</span>: book._id });
   notify(<span class="hljs-string">'Saved'</span>);
   NProgress.done();
   Router.push(<span class="hljs-string">`/admin/book-detail?slug=<span class="hljs-subst">${editedBook.slug}</span>`</span>, <span class="hljs-string">`/admin/book-detail/<span class="hljs-subst">${editedBook.slug}</span>`</span>);
 } <span class="hljs-keyword">catch</span> (err) {
   notify(err);
   NProgress.done();
 }
};</code></pre><p>Note that <code>editBook()</code> returns the <code>editedBook</code> object to the client. This object has a <code>slug</code> parameter. We use <code>editedBook.slug</code> to redirect a user to the <code>BookDetail</code> page of the edited book (instead of the old book, since a user might have changed the book's name and therefore slug).</p>
<p>After <code>editBook</code> returns <code>editedBook</code> object we indicate success to user with <code>notify()</code> and <code>Nprogress.done()</code>.</p>
<p>At the end, our app redirects the Admin user to the <code>BookDetail</code> page (<code>pages/admin/book-detail.js</code>) that we introduce later in this chapter.</p>
<p>Again, <code>data</code> inside the <code>editBookOnSave = async (data)</code> function is <code>this.state.book</code>, because we defined our <code>onSave()</code> function as <code>onSave(this.state.book)</code> (in the <code>EditBook</code> component), and we pointed <code>onSave()</code> to <code>editBookOnSave()</code>: <code>onSave={this.editBookOnSave}</code>. </p>
<p>You'll notice that unlike passing data without modification (<code>addBook(data);</code>), here we <em>add</em> an <code>id</code> to our data. Thus the syntax is <code>editBook({ ...data, id: book._id });</code> instead of <code>editBook(data);</code>.</p>
<p>In summary, we get:<br><code>pages/admin/edit-book.js</code> :</p>
<pre><code><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">'next/router'</span>;
<span class="hljs-keyword">import</span> NProgress <span class="hljs-keyword">from</span> <span class="hljs-string">'nprogress'</span>;
<span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-built_in">Error</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/error'</span>;

<span class="hljs-keyword">import</span> EditBookComp <span class="hljs-keyword">from</span> <span class="hljs-string">'../../components/admin/EditBook'</span>;
<span class="hljs-keyword">import</span> { getBookDetail, editBook } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../lib/api/admin'</span>;
<span class="hljs-keyword">import</span> withAuth <span class="hljs-keyword">from</span> <span class="hljs-string">'../../lib/withAuth'</span>;
<span class="hljs-keyword">import</span> notify <span class="hljs-keyword">from</span> <span class="hljs-string">'../../lib/notifier'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EditBook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
 <span class="hljs-keyword">static</span> propTypes = {
   <span class="hljs-attr">slug</span>: PropTypes.string.isRequired,
 };

 <span class="hljs-keyword">static</span> getInitialProps({ query }) {
   <span class="hljs-keyword">return</span> { <span class="hljs-attr">slug</span>: query.slug };
 }

 state = {
   <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span>,
   <span class="hljs-attr">book</span>: <span class="hljs-literal">null</span>,
 };

 <span class="hljs-keyword">async</span> componentDidMount() {
   NProgress.start();

   <span class="hljs-keyword">try</span> {
     <span class="hljs-keyword">const</span> book = <span class="hljs-keyword">await</span> getBookDetail({ <span class="hljs-attr">slug</span>: <span class="hljs-keyword">this</span>.props.slug });
     <span class="hljs-keyword">this</span>.setState({ book }); <span class="hljs-comment">// eslint-disable-line</span>
     NProgress.done();
   } <span class="hljs-keyword">catch</span> (err) {
     <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">error</span>: err.message || err.toString() }); <span class="hljs-comment">// eslint-disable-line</span>
     NProgress.done();
   }
 }

 editBookOnSave = <span class="hljs-keyword">async</span> (data) =&gt; {
   <span class="hljs-keyword">const</span> { book } = <span class="hljs-keyword">this</span>.state;
   NProgress.start();

   <span class="hljs-keyword">try</span> {
     <span class="hljs-keyword">const</span> editedBook = <span class="hljs-keyword">await</span> editBook({ ...data, <span class="hljs-attr">id</span>: book._id });
     notify(<span class="hljs-string">'Saved'</span>);
     NProgress.done();
     Router.push(<span class="hljs-string">`/admin/book-detail?slug=<span class="hljs-subst">${editedBook.slug}</span>`</span>, <span class="hljs-string">`/admin/book-detail/<span class="hljs-subst">${editedBook.slug}</span>`</span>);
   } <span class="hljs-keyword">catch</span> (err) {
     notify(err);
     NProgress.done();
   }
 };

 render() {
   <span class="hljs-keyword">const</span> { book, error } = <span class="hljs-keyword">this</span>.state;

   <span class="hljs-keyword">if</span> (error) {
     notify(error);
     <span class="hljs-keyword">return</span> &lt;Error statusCode={500} /&gt;;
   }

   if (!book) {
     return null;
   }

   return (
     &lt;div&gt;
       &lt;EditBookComp onSave={this.editBookOnSave} book={book} /&gt;
     &lt;/div&gt;
   );
 }
}

export default withAuth(EditBook);</code></pre></li>
<li><p>The <code>book-detail.js</code> page has two main purposes. The first is to show book data (such as <code>name</code>, <code>githubRepo</code>, <code>chapters</code>, and more) to the Admin user. The second is to sync content. This page will have a <code>Sync</code> button that our Admin clicks to get content from Github.</p>
<p>Similar to our <code>edit-book.js</code> page, we need to display book data. We do it the same way as we did on <code>edit-book.js</code>.</p>
<ul>
<li><p><code>getInitialProps()</code>:</p>
<pre><code> <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">getInitialProps</span><span class="hljs-params">({ query })</span> </span>{
 <span class="hljs-keyword">return</span> { slug: query.slug };
}</code></pre></li>
<li><p>API method <code>getBookDetail()</code> inside lifecycle hook <code>componentDidMount</code>:</p>
<pre><code>async component<span class="hljs-constructor">DidMount()</span> {
 <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NProgress</span>.</span></span>start<span class="hljs-literal">()</span>;
 <span class="hljs-keyword">try</span> {
   const book = await get<span class="hljs-constructor">BookDetail({ <span class="hljs-params">slug</span>: <span class="hljs-params">this</span>.<span class="hljs-params">props</span>.<span class="hljs-params">slug</span> })</span>;
   this.set<span class="hljs-constructor">State({ <span class="hljs-params">book</span>, <span class="hljs-params">loading</span>: <span class="hljs-params">false</span> })</span>; <span class="hljs-comment">// eslint-disable-line</span>
   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NProgress</span>.</span></span><span class="hljs-keyword">done</span><span class="hljs-literal">()</span>;
 } catch (err) {
   this.set<span class="hljs-constructor">State({ <span class="hljs-params">loading</span>: <span class="hljs-params">false</span>, <span class="hljs-params">error</span>: <span class="hljs-params">err</span>.<span class="hljs-params">message</span> <span class="hljs-operator">||</span> <span class="hljs-params">err</span>.<span class="hljs-params">toString</span>()</span> }); <span class="hljs-comment">// eslint-disable-line</span>
   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NProgress</span>.</span></span><span class="hljs-keyword">done</span><span class="hljs-literal">()</span>;
 }
}</code></pre></li>
<li><p>Passing props to component: <code>&lt;MyBook {...this.props} {...this.state} /&gt;</code></p>
</li>
</ul>
<p>To sync content on the button click, add the function <code>handleSyncContent()</code> to the <code>onClick</code> handler: </p>
<pre><code>&lt;Button raised onClick={handle<span class="hljs-constructor">SyncContent(<span class="hljs-params">book</span>.<span class="hljs-params">_id</span>)</span>}&gt;
 Sync <span class="hljs-keyword">with</span> Github
&lt;/Button&gt;</code></pre><p>We call the API method <code>syncBookContent()</code> (<a target="_blank" href="https://builderbook.org/books/builder-book/github-integration-admin-dashboard-testing-admin-ux-and-github-integration#api-methods" rel="noopener noreferrer">discussed in Admin Dashboard section</a>) inside the <code>handleSyncContent()</code> function:</p>
<pre><code><span class="hljs-keyword">const</span> handleSyncContent = bookId =&gt; <span class="hljs-keyword">async</span> () =&gt; {
<span class="hljs-keyword">try</span> {
 <span class="hljs-keyword">await</span> syncBookContent({ bookId });
 notify(<span class="hljs-string">'Synced'</span>);
} <span class="hljs-keyword">catch</span> (err) {
 notify(err);
}
};</code></pre><p>Our <code>book-detail.js</code> page will now have a list of chapters with hyperlinked titles.</p>
<p>Final code for this page:<br><code>pages/admin/book-detail.js</code> :</p>
<pre><code><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> NProgress <span class="hljs-keyword">from</span> <span class="hljs-string">'nprogress'</span>;
<span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>;
<span class="hljs-keyword">import</span> Error <span class="hljs-keyword">from</span> <span class="hljs-string">'next/error'</span>;
<span class="hljs-keyword">import</span> Link <span class="hljs-keyword">from</span> <span class="hljs-string">'next/link'</span>;
<span class="hljs-keyword">import</span> Button <span class="hljs-keyword">from</span> <span class="hljs-string">'@material-ui/core/Button'</span>;

<span class="hljs-keyword">import</span> { getBookDetail, syncBookContent } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../lib/api/admin'</span>;
<span class="hljs-keyword">import</span> withAuth <span class="hljs-keyword">from</span> <span class="hljs-string">'../../lib/withAuth'</span>;
<span class="hljs-keyword">import</span> notify <span class="hljs-keyword">from</span> <span class="hljs-string">'../../lib/notifier'</span>;

const handleSyncContent = bookId =&gt; async () =&gt; {
 <span class="hljs-keyword">try</span> {
   <span class="hljs-keyword">await</span> syncBookContent({ bookId });
   notify(<span class="hljs-string">'Synced'</span>);
 } <span class="hljs-keyword">catch</span> (err) {
   notify(err);
 }
};

const MyBook = <span class="hljs-function"><span class="hljs-params">({ book, error })</span> =&gt;</span> {
 <span class="hljs-keyword">if</span> (error) {
   notify(error);
   <span class="hljs-keyword">return</span> &lt;Error statusCode={<span class="hljs-number">500</span>} /&gt;;
 }

 <span class="hljs-keyword">if</span> (!book) {
   <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
 }

 const { chapters = [] } = book;

 <span class="hljs-keyword">return</span> (
   &lt;div style={{ padding: <span class="hljs-string">'10px 45px'</span> }}&gt;
     &lt;h2&gt;{book.name}&lt;/h2&gt;
     &lt;a href={`<span class="javascript">https:<span class="hljs-comment">//github.com/${book.githubRepo}</span></span>`} target=<span class="hljs-string">"_blank"</span> rel=<span class="hljs-string">"noopener noreferrer"</span>&gt;
       Repo <span class="hljs-literal">on</span> Github
     &lt;/a&gt;
     &lt;p /&gt;
     &lt;Button raised onClick={handleSyncContent(book._id)}&gt;
       Sync with Github
     &lt;/Button&gt;{<span class="hljs-string">' '</span>}
     &lt;Link <span class="hljs-keyword">as</span>={`<span class="javascript">/admin/edit-book/${book.slug}</span>`} href={`<span class="javascript">/admin/edit-book?slug=${book.slug}</span>`}&gt;
       &lt;Button raised&gt;Edit book&lt;/Button&gt;
     &lt;/Link&gt;
     &lt;ul&gt;
       {chapters.map(ch =&gt; (
         &lt;li key={ch._id}&gt;
           &lt;Link
             <span class="hljs-keyword">as</span>={`<span class="javascript">/books/${book.slug}/${ch.slug}</span>`}
             href={`<span class="javascript">/public/read-chapter?bookSlug=${book.slug}&amp;chapterSlug=${ch.slug}</span>`}
           &gt;
             &lt;a&gt;{ch.title}&lt;/a&gt;
           &lt;/Link&gt;
         &lt;/li&gt;
       ))}
     &lt;/ul&gt;
   &lt;/div&gt;
 );
};

MyBook.propTypes = {
 book: PropTypes.shape({
   name: PropTypes.string.isRequired,
 }),
 error: PropTypes.string,
};

MyBook.defaultProps = {
 book: <span class="hljs-literal">null</span>,
 error: <span class="hljs-literal">null</span>,
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBookWithData</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> {</span>
 static propTypes = {
   slug: PropTypes.string.isRequired,
 };

 static getInitialProps({ query }) {
   <span class="hljs-keyword">return</span> { slug: query.slug };
 }

 state = {
   loading: <span class="hljs-literal">true</span>,
   error: <span class="hljs-literal">null</span>,
   book: <span class="hljs-literal">null</span>,
 };

 async componentDidMount() {
   NProgress.start();
   <span class="hljs-keyword">try</span> {
     const book = <span class="hljs-keyword">await</span> getBookDetail({ slug: <span class="hljs-keyword">this</span>.props.slug });
     <span class="hljs-keyword">this</span>.setState({ book, loading: <span class="hljs-literal">false</span> }); <span class="hljs-regexp">//</span> eslint-disable-line
     NProgress.done();
   } <span class="hljs-keyword">catch</span> (err) {
     <span class="hljs-keyword">this</span>.setState({ loading: <span class="hljs-literal">false</span>, error: err.message || err.toString() }); <span class="hljs-regexp">//</span> eslint-disable-line
     NProgress.done();
   }
 }

 render() {
   <span class="hljs-keyword">return</span> &lt;MyBook {...<span class="hljs-keyword">this</span>.props} {...<span class="hljs-keyword">this</span>.state} /&gt;;
 }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> withAuth(MyBookWithData);</code></pre></li>
</ol>
<p>We are almost at the end of this section. Before we finish, let's make a small readability improvement.</p>
<p>Go back to <code>pages/public/read-chapter.js</code>. To pass <code>bookSLug</code> and <code>chapterSlug</code> parameters to the page and render this page on our server, we use <code>app.render()</code> (<a target="_blank" href="https://builderbook.org/books/builder-book/book-and-chapter-models-internal-api-render-chapter#page" rel="noopener noreferrer">discussed before in Chapter 5</a>):</p>
<pre><code>server.get(<span class="hljs-string">'/books/:bookSlug/:chapterSlug'</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> {
  const { bookSlug, chapterSlug } = req.params;
  app.render(req, res, <span class="hljs-string">'/public/read-chapter'</span>, { bookSlug, chapterSlug });
});</code></pre><p>When our app user navigates to the <code>/books/:bookSlug/:chapterSlug</code> route, we render the <code>/public/read-chapter</code> page on our server with <code>bookSLug</code> and <code>chapterSlug</code> parameters extracted from the route.</p>
<p>We have to do the same thing for our Admin's <code>edit-book.js</code> and <code>book-detail.js</code> pages. We need to extract a book's <code>slug</code> from the routes of these pages, pass this <code>slug</code> to the server, and then render <code>pages/admin/edit-book.js</code> and <code>pages/admin/book-detail.js</code>:</p>
<pre><code>server.get(<span class="hljs-string">'/admin/book-detail/:slug'</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> {
  const { slug } = req.params;
  app.render(req, res, <span class="hljs-string">'/admin/book-detail'</span>, { slug });
});

server.get(<span class="hljs-string">'/admin/edit-book/:slug'</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> {
  const { slug } = req.params;
  app.render(req, res, <span class="hljs-string">'/admin/edit-book'</span>, { slug });
});</code></pre><p>We can add the code snippet above to our main server code at <code>server/app.js</code> - but that file is getting big.</p>
<p>Instead, let's move all three Express routes to a new file <code>routesWithSlug.js</code>:<br><code>server/routesWithSlug.js</code> :</p>
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">routesWithSlug</span>(<span class="hljs-params">{ server, app }</span>) </span>{
  server.get(<span class="hljs-string">'/books/:bookSlug/:chapterSlug'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> { bookSlug, chapterSlug } = req.params;
    app.render(req, res, <span class="hljs-string">'/public/read-chapter'</span>, { bookSlug, chapterSlug });
  });

  server.get(<span class="hljs-string">'/admin/book-detail/:slug'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> { slug } = req.params;
    app.render(req, res, <span class="hljs-string">'/admin/book-detail'</span>, { slug });
  });

  server.get(<span class="hljs-string">'/admin/edit-book/:slug'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> { slug } = req.params;
    app.render(req, res, <span class="hljs-string">'/admin/edit-book'</span>, { slug });
  });
}</code></pre><p>Go to <code>server/app.js</code>. Import this function with:</p>
<pre>import routesWithSlug from './routesWithSlug';</pre>

<p>Then initialize routes on the server with <code>routesWithSlug({ server, app })</code>. Add it like this::</p>
<pre><code><span class="hljs-keyword">server</span>.use(<span class="hljs-keyword">session</span>(sess));

auth({ <span class="hljs-keyword">server</span>, ROOT_URL });
api(<span class="hljs-keyword">server</span>);
routesWithSlug({ <span class="hljs-keyword">server</span>, app });</code></pre><p>We are ready for testing. </p>
<p>In the next section, we will improve our <code>Header</code> component. And in the section after that, we will test out entire Admin flow, which includes syncing content between our database and Github.</p>
<h4 style="color: #FFF;">
        <a name="redirects-for-admin-and-customer-users" href="#redirects-for-admin-and-customer-users" style="color: #FFF;">
          <i class="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer; color: FFF;">
              link
            </i>
        </a>
        Redirects for Admin and Customer users
      </h4><p>One problem is the UX for our Customer user. After a login event, we should redirect the Customer to <code>/my-books</code>, not to <code>/admin</code>.</p>
<p>Open <code>server/google.js</code> and find the following Express route:</p>
<pre><code>server.get(
  <span class="hljs-string">'/oauth2callback'</span>,
  passport.authenticate(<span class="hljs-string">'google'</span>, {
    failureRedirect: <span class="hljs-string">'/login'</span>,
  }),
  <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> {
    res.redirect(<span class="hljs-string">'/admin'</span>);
  },
);</code></pre><p>We discussed this Express route in detail <a target="_blank" href="https://builderbook.org/books/builder-book/authentication-hoc-promise-async-await-static-method-for-user-model-google-oauth#express-routes-for-auth-" rel="noopener noreferrer">in Chapter 3</a>. Passport makes the <code>user</code> object available at <code>req.user</code>. Similar to above, use <code>req.user.isAdmin</code> to check if a user is Admin:</p>
<pre><code><span class="hljs-keyword">server</span>.<span class="hljs-keyword">get</span>(
  <span class="hljs-string">'/oauth2callback'</span>,
  passport.authenticate(<span class="hljs-string">'google'</span>, {
    failureRedirect: <span class="hljs-string">'/login'</span>,
  }),
  (req, res) =&gt; {
    <span class="hljs-keyword">if</span> (req.<span class="hljs-keyword">user</span> &amp;&amp; req.<span class="hljs-keyword">user</span>.isAdmin) {
      res.redirect(<span class="hljs-string">'/admin'</span>);
    } <span class="hljs-keyword">else</span> {
      res.redirect(<span class="hljs-string">'/my-books'</span>);
    }
  },
);</code></pre><p>Make sure your user is a Customer (in DB, User doc's parameter <code>isAdmin</code> is <code>false</code>), then log out and log back in. After logging in, you will be <em>automatically</em> redirected to <code>/my-books</code> route instead of <code>/admin</code>.</p>
<p>Yet another UX problem, currently the Admin page (<code>pages/admin/index.js</code>) is available to both Admin and Customer users. But only Admin user should be able to see Admin page.</p>
<p>To solve this problem, we have to update <code>withAuth</code> HOC: check value of <code>user.isAdmin</code> and add <code>adminRequired</code> parameter. Here is a behaviour of <code>adminRequired</code> parameter of <code>withAuth</code> HOC:</p>
<ul>
<li>When <code>withAuth</code> HOC wraps page component and <code>adminRequired</code> is <code>true</code> then Admin page will render and be displayed to Admin user.</li>
<li>When <code>withAuth</code> HOC wraps page component and <code>adminRequired</code> is <code>true</code> then Admin page will not render and return <code>null</code> to Customer user. App will redirect Customer user to <code>/my-books</code> route.</li>
</ul>
<p>Open <code>lib/withAuth.js</code> and update it as follows:</p>
<pre><code><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>;
<span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">'next/router'</span>;

<span class="hljs-keyword">let</span> globalUser = <span class="hljs-literal">null</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (
  Page,
  { loginRequired = <span class="hljs-literal">true</span>, logoutRequired = <span class="hljs-literal">false</span>, adminRequired = <span class="hljs-literal">false</span> } = {},
) =&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">static</span> propTypes = {
      <span class="hljs-attr">user</span>: PropTypes.shape({
        <span class="hljs-attr">id</span>: PropTypes.string,
        <span class="hljs-attr">isAdmin</span>: PropTypes.bool,
      }),
      <span class="hljs-attr">isFromServer</span>: PropTypes.bool.isRequired,
    };

    <span class="hljs-keyword">static</span> defaultProps = {
      <span class="hljs-attr">user</span>: <span class="hljs-literal">null</span>,
    };

    componentDidMount() {
      <span class="hljs-keyword">const</span> { user, isFromServer } = <span class="hljs-keyword">this</span>.props;

      <span class="hljs-keyword">if</span> (isFromServer) {
        globalUser = user;
      }

      <span class="hljs-keyword">if</span> (loginRequired &amp;&amp; !logoutRequired &amp;&amp; !user) {
        Router.push(<span class="hljs-string">'/public/login'</span>, <span class="hljs-string">'/login'</span>);
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (logoutRequired &amp;&amp; user) {
        Router.push(<span class="hljs-string">'/'</span>);
      }

      <span class="hljs-keyword">if</span> (adminRequired &amp;&amp; (!user || !user.isAdmin)) {
        Router.push(<span class="hljs-string">'/customer/my-books'</span>, <span class="hljs-string">'/my-books'</span>);
      }
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> getInitialProps(ctx) {
      <span class="hljs-keyword">const</span> isFromServer = !!ctx.req;
      <span class="hljs-keyword">const</span> user = ctx.req ? ctx.req.user &amp;&amp; ctx.req.user.toObject() : globalUser;

      <span class="hljs-keyword">if</span> (isFromServer &amp;&amp; user) {
        user._id = user._id.toString();
      }

      <span class="hljs-keyword">const</span> props = { user, isFromServer };

      <span class="hljs-keyword">if</span> (Page.getInitialProps) {
        <span class="hljs-built_in">Object</span>.assign(props, (<span class="hljs-keyword">await</span> Page.getInitialProps(ctx)) || {});
      }

      <span class="hljs-keyword">return</span> props;
    }

    render() {
      <span class="hljs-keyword">const</span> { user } = <span class="hljs-keyword">this</span>.props;

      <span class="hljs-keyword">if</span> (loginRequired &amp;&amp; !logoutRequired &amp;&amp; !user) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (logoutRequired &amp;&amp; user) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (adminRequired &amp;&amp; (!user || !user.isAdmin)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Page</span> {<span class="hljs-attr">...this.props</span>} /&gt;</span>;
    }
};</span></code></pre><p>Note, that we introduced <code>adminRequired</code> parameter in addition to <code>loginRequired</code> and <code>logoutRequired</code>, find line with <code>loginRequired = true, logoutRequired = false, adminRequired = false</code>.</p>
<p>We redirect Customer (non-Admin) user to <code>/my-books</code> if user tries to access any page with <code>adminRequired: true</code>:</p>
<pre><code><span class="hljs-keyword">if</span> (adminRequired &amp;&amp; (!<span class="hljs-keyword">user</span> || !<span class="hljs-keyword">user</span>.isAdmin)) {
  Router.push(<span class="hljs-string">'/customer/my-books'</span>, <span class="hljs-string">'/my-books'</span>);
}</code></pre><p>We render <code>null</code> when Customer (non-Admin) user tries to access any page with <code>adminRequired: true</code>:</p>
<pre><code><span class="hljs-keyword">if</span> (adminRequired &amp;&amp; (!<span class="hljs-keyword">user</span> || !<span class="hljs-keyword">user</span>.isAdmin)) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}</code></pre><p>Finally, open <code>pages/admin/index.js</code>, let's add <code>adminRequired</code> to Admin page. Find line:</p>
<pre><code><span class="hljs-builtin-name">export</span><span class="hljs-built_in"> default </span>withAuth(IndexWithData);</code></pre><p>Update it like this:</p>
<pre><code><span class="hljs-builtin-name">export</span><span class="hljs-built_in"> default </span>withAuth(IndexWithData, { adminRequired: <span class="hljs-literal">true</span> });</code></pre><p>Done.</p>
<p>Go ahead and test.</p>
<p>Make sure your user is a Customer (in DB, your User doc's parameter <code>isAdmin</code> is set to <code>false</code>). Try to access <code>/admin</code> route, you will be <em>automatically</em> redirected to <code>/my-books</code> route.</p>
<p>You can also test that Admin page renders <code>null</code> for Customer user. Simply comment out following block of code inside <code>withAuth</code> HOC:</p>
<pre><code><span class="hljs-keyword">if</span> (adminRequired &amp;&amp; (!<span class="hljs-keyword">user</span> || !<span class="hljs-keyword">user</span>.isAdmin)) {
  Router.push(<span class="hljs-string">'/customer/my-books'</span>, <span class="hljs-string">'/my-books'</span>);
}</code></pre><p>Then, as Customer user, try to access <code>/admin</code> route, you will see blank page:<br><img src="https://user-images.githubusercontent.com/10218864/46629187-d3db5d80-caf4-11e8-996a-0e4f52337c35.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<h2 class="chapter-section" style="color: #FFF; font-weight: 400;">
        <a name="update-header-component" href="#update-header-component" style="color: #FFF;"> 
          <i class="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer; color: FFF;">
            link
          </i>
        </a>
        <span class="section-anchor" name="update-header-component">
          Update Header component
        </span>
      </h2><p>On our server, we added a redirect to the <code>/admin</code> page. Now we need to add Customer/Admin logic to our <code>Header</code> component.</p>
<p>For a logged-out user, the <code>Header</code> component looks the same, and this is how we want it to be.<br><img src="https://user-images.githubusercontent.com/10218864/36345319-dd6ca3c4-13dc-11e8-9ec1-2b17d3c7d61f.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<p>But let's change how the <code>Header</code> component looks to a logged-in user. The logged-in user can either be a Customer or Admin.</p>
<p>Currently, the <code>Header</code> component looks exactly same to Customer and Admin users:<br><img src="https://user-images.githubusercontent.com/10218864/36345364-d4f466ae-13dd-11e8-9f94-13312e42087b.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<p>We want to make 3 changes to our <code>Header</code> component:</p>
<ol>
<li>Remove the <code>Settings</code> link from the left</li>
<li>Replace the <code>Got question?</code> link from the <code>MenuDrop</code> component with either <code>My books</code> link for a Customer user <em>or</em> <code>Admin</code> link for an Admin user</li>
<li>For an Admin user who did not connect Github to our app, we want to show the <code>Connect Github</code> button</li>
</ol>
<p>Let's discuss each step.</p>
<ol>
<li><p>That's easy. Simply delete the <code>&lt;div&gt;</code> element containing the <code>Settings</code> link.</p>
</li>
<li><p>This is where we need to use logic. Since a <code>user</code> object is available in the <code>Header</code> component (our <code>App</code> HOC passes <code>user</code> to <code>Header</code>), we can check if a user is an Admin with <code>user.isAdmin</code>.</p>
<p>For the Customer user, <code>{user &amp;&amp; !user.isAdmin ? ... : ...}</code>.<br>For the Admin user, <code>{user &amp;&amp; user.isAdmin ? ... : ...}</code>.</p>
<p>Open <code>components/Header.js</code> and replace the following code snippet:</p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">whiteSpace:</span> ' <span class="hljs-attr">nowrap</span>' }}&gt;</span>
 {user.avatarUrl ? (
   <span class="hljs-tag">&lt;<span class="hljs-name">MenuDrop</span> <span class="hljs-attr">options</span>=<span class="hljs-string">{optionsMenu}</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{user.avatarUrl}</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">{user.displayName}</span> /&gt;</span>
 ) : null}
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>with a snippet that checks if a user is an Admin:</p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">whiteSpace:</span> ' <span class="hljs-attr">nowrap</span>' }}&gt;</span>
 {!user.isAdmin ? (
   <span class="hljs-tag">&lt;<span class="hljs-name">MenuDrop</span>
     <span class="hljs-attr">options</span>=<span class="hljs-string">{optionsMenuCustomer}</span>
     <span class="hljs-attr">src</span>=<span class="hljs-string">{user.avatarUrl}</span>
     <span class="hljs-attr">alt</span>=<span class="hljs-string">{user.displayName}</span>
   /&gt;</span>
 ) : null}
 {user.isAdmin ? (
   <span class="hljs-tag">&lt;<span class="hljs-name">MenuDrop</span>
     <span class="hljs-attr">options</span>=<span class="hljs-string">{optionsMenuAdmin}</span>
     <span class="hljs-attr">src</span>=<span class="hljs-string">{user.avatarUrl}</span>
     <span class="hljs-attr">alt</span>=<span class="hljs-string">{user.displayName}</span>
   /&gt;</span>
 ) : null}
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>Above, we simply used <code>{condition ? value1 : value2}</code></p>
<p>We need to define <code>optionsMenuCustomer</code> and <code>optionsMenuAdmin</code>. Replace the following code snippet:</p>
<pre><code><span class="hljs-keyword">const</span> optionsMenu = [
 {
   <span class="hljs-built_in">text</span>: <span class="hljs-string">'Got question?'</span>,
   href: <span class="hljs-string">'https://github.com/builderbook/builderbook/issues'</span>,
 },
 {
   <span class="hljs-built_in">text</span>: <span class="hljs-string">'Log out'</span>,
   href: <span class="hljs-string">'/logout'</span>,
 },
];</code></pre><p>with:</p>
<pre><code><span class="hljs-keyword">const</span> optionsMenuCustomer = [
 {
   <span class="hljs-built_in">text</span>: <span class="hljs-string">'My books'</span>,
   href: <span class="hljs-string">'/customer/my-books'</span>,
   as: <span class="hljs-string">'/my-books'</span>,
 },
 {
   <span class="hljs-built_in">text</span>: <span class="hljs-string">'Log out'</span>,
   href: <span class="hljs-string">'/logout'</span>,
 },
];

<span class="hljs-keyword">const</span> optionsMenuAdmin = [
 {
   <span class="hljs-built_in">text</span>: <span class="hljs-string">'Admin'</span>,
   href: <span class="hljs-string">'/admin'</span>,
 },
 {
   <span class="hljs-built_in">text</span>: <span class="hljs-string">'Log out'</span>,
   href: <span class="hljs-string">'/logout'</span>,
 },
];</code></pre></li>
<li><p>For an Admin user who did not connect Github yet, <code>{user &amp;&amp; user.isAdmin &amp;&amp; !user.isGithubConnected ? ... : ...}</code>.<br>Add an extra grid column that contains the <code>Connect Github</code> button:</p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-name">Grid</span> <span class="hljs-attr">item</span> <span class="hljs-attr">sm</span>=<span class="hljs-string">{2}</span> <span class="hljs-attr">xs</span>=<span class="hljs-string">{2}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">textAlign:</span> '<span class="hljs-attr">right</span>' }}&gt;</span>
 {user &amp;&amp; user.isAdmin &amp;&amp; !user.isGithubConnected ? (
   <span class="hljs-tag">&lt;<span class="hljs-name">Hidden</span> <span class="hljs-attr">smDown</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/auth/github"</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">raised</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span>&gt;</span>
       Connect Github
       <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
     <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">Hidden</span>&gt;</span>
 ) : null}
<span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span></code></pre></li>
</ol>
<p>Combine code from steps 1 to 3, and the refactored <code>Header</code> component will look like:<br><code>components/Header.js</code> :</p>
<pre><code><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>;
<span class="hljs-keyword">import</span> Link <span class="hljs-keyword">from</span> <span class="hljs-string">'next/link'</span>;
<span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">'next/router'</span>;
<span class="hljs-keyword">import</span> NProgress <span class="hljs-keyword">from</span> <span class="hljs-string">'nprogress'</span>;
<span class="hljs-keyword">import</span> Toolbar <span class="hljs-keyword">from</span> <span class="hljs-string">'@material-ui/core/Toolbar'</span>;
<span class="hljs-keyword">import</span> Grid <span class="hljs-keyword">from</span> <span class="hljs-string">'@material-ui/core/Grid'</span>;
<span class="hljs-keyword">import</span> Hidden <span class="hljs-keyword">from</span> <span class="hljs-string">'@material-ui/core/Hidden'</span>;
<span class="hljs-keyword">import</span> Button <span class="hljs-keyword">from</span> <span class="hljs-string">'@material-ui/core/Button'</span>;
<span class="hljs-keyword">import</span> Avatar <span class="hljs-keyword">from</span> <span class="hljs-string">'@material-ui/core/Avatar'</span>;

<span class="hljs-keyword">import</span> MenuDrop <span class="hljs-keyword">from</span> <span class="hljs-string">'./MenuDrop'</span>;

<span class="hljs-keyword">import</span> { styleToolbar } <span class="hljs-keyword">from</span> <span class="hljs-string">'./SharedStyles'</span>;

Router.onRouteChangeStart = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  NProgress.start();
};
Router.onRouteChangeComplete = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> NProgress.done();
Router.onRouteChangeError = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> NProgress.done();

const optionsMenuCustomer = [
  {
    text: <span class="hljs-string">'My books'</span>,
    href: <span class="hljs-string">'/customer/my-books'</span>,
    as: <span class="hljs-string">'/my-books'</span>,
  },
  {
    text: <span class="hljs-string">'Log out'</span>,
    href: <span class="hljs-string">'/logout'</span>,
  },
];

const optionsMenuAdmin = [
  {
    text: <span class="hljs-string">'Admin'</span>,
    href: <span class="hljs-string">'/admin'</span>,
  },
  {
    text: <span class="hljs-string">'Log out'</span>,
    href: <span class="hljs-string">'/logout'</span>,
  },
];

function Header({ user }) {
  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;Toolbar style={styleToolbar}&gt;
        &lt;Grid container direction=<span class="hljs-string">"row"</span> justify=<span class="hljs-string">"space-around"</span> alignItems=<span class="hljs-string">"center"</span>&gt;
          &lt;Grid item sm={<span class="hljs-number">9</span>} xs={<span class="hljs-number">8</span>} style={{ textAlign: <span class="hljs-string">'left'</span> }}&gt;
            {!user ? (
              &lt;Link prefetch href=<span class="hljs-string">"/"</span>&gt;
                &lt;Avatar
                  src=<span class="hljs-string">"https://storage.googleapis.com/builderbook/logo.svg"</span>
                  alt=<span class="hljs-string">"Builder Book logo"</span>
                  style={{ margin: <span class="hljs-string">'0px auto 0px 20px'</span>, cursor: <span class="hljs-string">'pointer'</span> }}
                /&gt;
              &lt;/Link&gt;
            ) : <span class="hljs-literal">null</span>}
          &lt;/Grid&gt;
          &lt;Grid item sm={<span class="hljs-number">2</span>} xs={<span class="hljs-number">2</span>} style={{ textAlign: <span class="hljs-string">'right'</span> }}&gt;
            {user &amp;&amp; user.isAdmin &amp;&amp; !user.isGithubConnected ? (
              &lt;Hidden smDown&gt;
                &lt;a href=<span class="hljs-string">"/auth/github"</span>&gt;
                  &lt;Button variant=<span class="hljs-string">"contained"</span> color=<span class="hljs-string">"primary"</span>&gt;
                    Connect Github
                  &lt;/Button&gt;
                &lt;/a&gt;
              &lt;/Hidden&gt;
            ) : <span class="hljs-literal">null</span>}
          &lt;/Grid&gt;
          &lt;Grid item sm={<span class="hljs-number">1</span>} xs={<span class="hljs-number">2</span>} style={{ textAlign: <span class="hljs-string">'right'</span> }}&gt;
            {user ? (
                &lt;div style={{ whiteSpace: <span class="hljs-string">' nowrap'</span> }}&gt;
                  {!user.isAdmin ? (
                    &lt;MenuDrop
                      options={optionsMenuCustomer}
                      src={user.avatarUrl}
                      alt={user.displayName}
                    /&gt;
                  ) : <span class="hljs-literal">null</span>}
                  {user.isAdmin ? (
                    &lt;MenuDrop
                      options={optionsMenuAdmin}
                      src={user.avatarUrl}
                      alt={user.displayName}
                    /&gt;
                  ) : <span class="hljs-literal">null</span>}
                &lt;/div&gt;
              ) : (
                &lt;Link prefetch href=<span class="hljs-string">"/public/login"</span> <span class="hljs-keyword">as</span>=<span class="hljs-string">"/login"</span>&gt;
                  &lt;a style={{ margin: <span class="hljs-string">'0px 20px 0px auto'</span> }}&gt;Log <span class="hljs-keyword">in</span>&lt;/a&gt;
                &lt;/Link&gt;
              )}
          &lt;/Grid&gt;
        &lt;/Grid&gt;
      &lt;/Toolbar&gt;
    &lt;/div&gt;
  );
}

Header.propTypes = {
  user: PropTypes.shape({
    avatarUrl: PropTypes.string,
    displayName: PropTypes.string,
  }),
};

Header.defaultProps = {
  user: <span class="hljs-literal">null</span>,
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Header;</code></pre><p>Testing time.</p>
<p>Go to MongoDB Atlas, navigate to <code>test.users</code> collection of <code>test</code> database (that is part of <code>Cluster0</code> cluster), and find your user document.</p>
<ul>
<li><p>To test an Admin user. Set parameter <code>"isAdmin": true</code> and <code>"isGithubConnected": false</code> on the user document.<br>Start the app (<code>yarn dev</code>), go to the <code>/login</code> page, and log in. You'll be redirected to the <code>/admin</code> page:<br><img src="https://user-images.githubusercontent.com/10218864/36345703-dcb0f360-13e4-11e8-9362-202426e20771.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
</li>
<li><p>The above is an Admin user who did not connect Github. Set <code>"isAdmin": true</code> and <code>"isGithubConnected": true</code> on the user document.<br>Refresh the tab.<br><img src="https://user-images.githubusercontent.com/10218864/36345658-49efd99c-13e4-11e8-9e7c-364c6d9e1e8b.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
</li>
<li><p>Testing the Customer user is tricky since our app has no <code>/my-books</code> page.<br>Let's add the bare minimum of code we need to render this page. Create a file at <code>pages/customer/my-books.js</code> with the following content:<br><code>pages/customer/my-books.js</code> :</p>
<pre><code><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">import</span> withAuth <span class="hljs-keyword">from</span> <span class="hljs-string">'../../lib/withAuth'</span>;

<span class="hljs-keyword">const</span> MyBooks = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">padding:</span> '<span class="hljs-attr">10px</span> <span class="hljs-attr">45px</span>' }}&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Your books<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> withAuth(MyBooks);</code></pre><p>Also, since our server attempts to render the page from <code>/my-books</code> instead of <code>/customer/my-books</code>, we have to add some handler function to <code>server/app.js</code> to fix this.</p>
<p>Go to <code>server/app.js</code>. Below the <code>'/login': '/public/login',</code> line of code, add a new line of code <code>'/my-books': '/customer/my-books',</code>:</p>
<pre><code><span class="hljs-keyword">const</span> URL_MAP = {
  <span class="hljs-string">'/login'</span>: <span class="hljs-string">'/public/login'</span>,
  <span class="hljs-string">'/my-books'</span>: <span class="hljs-string">'/customer/my-books'</span>,
};</code></pre><p>Go to Atlas, in the <code>test.users</code> collection, edit your user document to make sure that parameter <code>"isAdmin": false</code>.<br>Log out and log in. After logging in, you are automatically redirected to <code>/admin</code>.<br>Go to <code>/my-books</code> page:<br><img src="https://user-images.githubusercontent.com/10218864/36345769-067fc40e-13e6-11e8-83a0-c7bb36d0375c.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
</li>
</ul>
<p>Good job if you see the proper UI.</p>
<h2 class="chapter-section" style="color: #FFF; font-weight: 400;">
        <a name="testing" href="#testing" style="color: #FFF;"> 
          <i class="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer; color: FFF;">
            link
          </i>
        </a>
        <span class="section-anchor" name="testing">
          Testing
        </span>
      </h2><p>In this section, we test out our <em>Admin</em> flow. We plan to test:</p>
<ul>
<li>connecting to Github</li>
<li>adding a new book</li>
<li>editing that new book</li>
<li>syncing content</li>
</ul>
<p>As we test our Admin flow - make sure that your user document in the database has the following parameters: <code>"isAdmin": true</code> and <code>"isGithubConnected": false</code>.</p>
<h4 style="color: #FFF;">
        <a name="connecting-github" href="#connecting-github" style="color: #FFF;">
          <i class="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer; color: FFF;">
              link
            </i>
        </a>
        Connecting Github
      </h4><p>So far, so good. Here we continue testing our Admin flow. Make sure that your user document has <code>"isAdmin": true</code> and <code>"isGithubConnected": false</code>. Log out and log into the app if necessary.<br><img src="https://user-images.githubusercontent.com/10218864/34746269-36eb4d5a-f548-11e7-8a21-e3bd4eef9d07.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<p>Before we click the <code>Connect Github</code> button:</p>
<ol>
<li><p>Go to Github and follow these <a target="_blank" href="https://developer.github.com/v3/guides/basics-of-authentication/#registering-your-app" rel="noopener noreferrer">instructions</a> on how to register your app and get <code>ClientID</code> and <code>SecretKey</code> API credentials. Add both credentials to your app's <code>.env</code> file as follows:</p>
<pre><code><span class="hljs-attr">Github_Test_ClientID</span>=<span class="hljs-string">"XXXXXX"</span>
<span class="hljs-attr">Github_Test_SecretKey</span>=<span class="hljs-string">"XXXXXX"</span></code></pre><p>Important note, Github does not support multiple domains in one registered app. We suggest you register two apps on Github, one for <code>http://localhost:8000</code> and a second for your production domain (in our case, it is <code>https://builderbook.org</code>).</p>
<p>For development, take the values of <code>ClientID</code> and <code>SecretKey</code> from your Github app registered with <code>http://localhost:8000</code>. Pass these values as <code>Github_Test_ClientID</code> and <code>Github_Test_SecretKey</code>.</p>
<p>For production, take the values of <code>ClientID</code> and <code>SecretKey</code> from your Github app registered with <code>https://yourdomain.com</code>. Pass these values as <code>Github_Live_ClientID</code> and <code>Github_Live_SecretKey</code>.</p>
<p>For both Github apps, the callback route is <code>/auth/github/callback</code>.</p>
</li>
<li><p>Open <code>server/app.js</code> and import the <code>setupGithub</code> function as <code>github</code>:</p>
<pre>const { setupGithub } = require('./github');</pre>

<p>Initiate it on the server with <code>github({ server });</code>. Add it like this: </p>
<pre><code>auth({ server, ROOT_URL });
github({<span class="hljs-built_in"> server </span>});
api(server);
routesWithSlug({ server, app });</code></pre></li>
</ol>
<p>You should monitor what happens to your user document on the database after you click <code>Connect Github</code>.</p>
<p>Go back to the browser and click the dark blue <code>Connect Github</code> button.<br><img src="https://user-images.githubusercontent.com/10218864/34748275-a460f940-f550-11e7-8338-deecc7303125.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<p>The button disappears, because <code>isGithubConnected</code> becomes <code>true</code>.</p>
<p>Go to the database and check your user document - you successfully connected Github if your app received <code>githubAccessToken</code> and saved it to the database and if <code>"isGithubConnected": true</code>.</p>
<h4 style="color: #FFF;">
        <a name="adding-new-book" href="#adding-new-book" style="color: #FFF;">
          <i class="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer; color: FFF;">
              link
            </i>
        </a>
        Adding new book
      </h4><p>Before we create a new book, let's add an <code>Add book</code> button to <code>pages/admin/index.js</code>:</p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/admin/add-book"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">variant</span>=<span class="hljs-string">"contained"</span>&gt;</span>Add book<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></code></pre><p>Add this button <em>above</em> the list of all books (<code>&lt;ul&gt;...&lt;/ul&gt;</code>):<br><img src="https://user-images.githubusercontent.com/26158226/36624934-295b4bee-18cb-11e8-9e22-8b4616386367.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<p>Now go to Github. To save time from creating your own new repo with content, fork our <a target="_blank" href="https://github.com/builderbook/demo-book" rel="noopener noreferrer">demo-book repo</a>.</p>
<p>Click the <code>Add book</code> button. You are now on the <code>/add-book</code> page:<br><img src="https://user-images.githubusercontent.com/26158226/36624935-297abe84-18cb-11e8-876c-3fb4eaedae14.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<p>Set a price, write a name, and pick a repo. We set <code>49</code>, <code>Demo Book</code>, and <code>builderbook/demo-book</code>, respectively:<br><img src="https://user-images.githubusercontent.com/26158226/36624936-299a03ca-18cb-11e8-9688-211b5a3c7de9.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<p>Click the <code>Save</code> button and you will see your newly added book at the top of the list:<br><img src="https://user-images.githubusercontent.com/26158226/36624937-29b37d82-18cb-11e8-94d0-d938e278079d.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<h4 style="color: #FFF;">
        <a name="editing-existing-book" href="#editing-existing-book" style="color: #FFF;">
          <i class="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer; color: FFF;">
              link
            </i>
        </a>
        Editing existing book
      </h4><p>Click <code>Demo Book</code> from the list of all books. You will go to the <code>pages/admin/book-detail.js</code> page for this book. We see the book's <code>name</code> and <code>githubRepo</code>, as well as two buttons that we are going to test:<br><img src="https://user-images.githubusercontent.com/26158226/36625802-7294dc3e-18db-11e8-90f5-9b0d6f3ee2e5.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<p>Click the <code>Edit book</code> button and you will go to <code>pages/admin/edit-book.js</code>. This page looks very similar to <code>pages/admin/add-book.js</code>, since both pages are mainly the <code>EditBook</code> component:<br><img src="https://user-images.githubusercontent.com/26158226/36624940-2dece24e-18cb-11e8-9088-b3a22622cf5e.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<h4 style="color: #FFF;">
        <a name="syncing-content" href="#syncing-content" style="color: #FFF;">
          <i class="material-icons" style="vertical-align: middle; opacity: 0.5; cursor: pointer; color: FFF;">
              link
            </i>
        </a>
        Syncing content
      </h4><p>Go to Github and check out the <code>introduction.md</code> file in the <code>demo-book</code> repo that you forked:<br><img src="https://user-images.githubusercontent.com/26158226/36624941-2e0b639a-18cb-11e8-8454-466ad6ce6cb7.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<p>Notice that this file has metadata at the top: <code>title</code>, <code>seoTitle</code>, <code>seoDescription</code>, and <code>isFree</code>. We discussed these parameters, as well as many others, in the <a target="_blank" href="https://builderbook.org/books/builder-book/book-and-chapter-models-internal-api-render-chapter#schema-for-chapter" rel="noopener noreferrer">Chapter Schema section</a> of Chapter 5.</p>
<p>Every chapter (<code>.md</code> file) that we create for our book needs to have this metadata section at the top. For chapters that are not free, replace the <code>isFree</code> parameter with <code>excerpt:""</code> and add some content between the quotes. This content will be a free preview, but all other content in the chapter will be hidden until a user buys the book. See <a target="_blank" href="https://github.com/builderbook/demo-book/blob/master/chapter-1.md" rel="noopener noreferrer"><code>chapter-1.md</code></a> in the <code>demo-book</code> repo for an example of <code>excerpt</code> content.</p>
<p>Now click the <code>Sync with Github</code> button on <code>pages/admin/book-detail.js</code>. You will see an in-app success message <code>Synced</code> at the top right. Refresh the page, and you will see a hyperlinked titles to the Introduction and Chapter 1 (titled <code>Example</code>):<br><img src="https://user-images.githubusercontent.com/26158226/36624942-2e27eab0-18cb-11e8-943e-038bde808059.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<p>Click on the Introduction link, and you will go to the <code>books/:bookSlug/:chapterSlug</code> page (this page's code is at <code>pages/public/read-chapter.js</code>). For our demo book, the page's URL is <code>http://localhost:8000/books/demo-book/introduction</code>:<br><img src="https://user-images.githubusercontent.com/26158226/36624944-3271dbb2-18cb-11e8-868c-ba93c4d3e033.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<p>Go back to Github and edit your <code>introduction.md</code> file by adding a sentence: <code>Hello world!</code>. You can add anything you want - feel free to add markdown content.<br><img src="https://user-images.githubusercontent.com/26158226/36624945-328b82f6-18cb-11e8-9115-f9f7326d6915.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<p>Go back to your Admin dashboard, then click <code>Demo Book</code>, then <code>Sync with Github</code>, and then finally the <code>Introduction</code> hyperlink:<br><img src="https://user-images.githubusercontent.com/26158226/36625832-0d975040-18dc-11e8-8823-3bd74f5496fa.png" style="border: 1px solid #ddd;" width="100%" alt="Builder Book"></p>
<p>Our app has successfully synced content between our database and Github's!</p>
<p>In this chapter, we added and tested all Admin pages in our app. Now you, as an Admin, can write content on Github and display it in your web app.</p>
<p>In the next chapter (Chapter 7), we will work on the <code>ReadChapter</code> page. Among other things, we will add an interactive Table of Contents.</p>
<br>

<hr>
<p>At the end of Chapter 6, your codebase should look like the codebase in <code>6-end</code>. The <a target="_blank" href="https://github.com/builderbook/builderbook/tree/master/book/6-end" rel="noopener noreferrer">6-end</a> folder is located at the root of the <code>book</code> directory inside the <a target="_blank" href="https://github.com/builderbook/builderbook" rel="noopener noreferrer">builderbook repo</a>.</p>
<p>Compare your codebase and make edits if needed.</p>
<p>Enjoying the book so far? Please share a quick <a target="_blank" href="https://goo.gl/forms/JdevtnCWsLwZTAio2" rel="noopener noreferrer">review</a>. You can update your review at any time.</p>
<hr>
<br></div></div>